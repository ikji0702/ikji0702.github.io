---
title: '.meta vs .uasset'
parmalink : /study/2025-07-08
date: 2025-07-08
tags:
  - Animation
  - Com2us TA Campus
---

> 

게임 개발에서 팀 협업은 필수다. Unity와 Unreal Engine은 각각 자신들의 방식으로 에셋을 관리하는데 이 때문에 Git이나 SVN 같은 버전 관리 시스템을 쓸 때에도 각각에 맞는 이해도와 활용법이 필요하다.
이번 글에서는 Unity와 언리얼 엔진의 에셋 관리 방식 차이, 그리고 협업 효율을 높일 수 있는 각 툴에 맞는 버전 관리 툴의 사용법에 대해 이야기해보려고 한다.





## Unity의 .meta 파일

### meta 파일이란?

Unity는 **텍스트 기반의 .meta 파일 시스템**을 사용한다. 프로젝트의 모든 에셋(텍스처, 모델, 스크립트 등)에 대해 별도의 .meta 파일을 생성한다. 에디터 상에서는 보이지 않고, 파일 탐색기에서 해당 파일을 확인할 수 있다.

```
Assets/
├── Models/
│   ├── Character.fbx
│   ├── Character.fbx.meta     ← 모델 파일의 메타데이터
│   ├── Weapon.fbx
│   └── Weapon.fbx.meta		  ← 모델 파일의 메타데이터
├── Textures/
│   ├── Character_Diffuse.png
│   ├── Character_Diffuse.png.meta       ← 텍스처 파일의 메타데이터
│   ├── Character_Normal.png
│   └── Character_Normal.png.meta        ← 텍스처 파일의 메타데이터
```

![image-20250708223010167](./../images/2025-07-08-.meta%20vs%20.uasset/image-20250708223010167.png)![image-20250708223018130](./../images/2025-07-08-.meta%20vs%20.uasset/image-20250708223018130.png)

파일말고, 이런 폴더도 메타파일이 존재한다.





### meta 파일에 저장되는 정보들

Unity의 .meta 파일은 텍스트 파일 형식으로 저장된다.

예를들어 텍스처 파일의 .png.meta 파일을 열어보면

```yaml
fileFormatVersion: 2
guid: c3288b589f2e9434e878f4df0baee157
TextureImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 11
  mipmaps:
    mipMapMode: 0
    enableMipMap: 1
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  vTOnly: 0
  ignoreMasterTextureLimit: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
.
.
.
```

- 파일 포맷 버전 정보
- guid(고유 식별자)
- 그리고 그 아래로 Texture Import 관련 설정들(예: mipmaps, bumpmap, isReadable, grayScaleToAlpha 등)

이런 식으로 텍스처와 관련된 익숙한 옵션들이 쭉 정리되어 있다.

마찬가지로, **.fbx.meta** 파일을 보면

```yaml
fileFormatVersion: 2
guid: d676f7763389e6344af52c5569bb4411
ModelImporter:
  serializedVersion: 21300
  internalIDToNameTable: []
  externalObjects: {}
  materials:
    materialImportMode: 2
    materialName: 0
    materialSearch: 1
    materialLocation: 1
  animations:
    legacyGenerateAnimations: 4
    bakeSimulation: 0
    resampleCurves: 1
    optimizeGameObjects: 0
    removeConstantScaleCurves: 1
    motionNodeName: 
    rigImportErrors: 
    rigImportWarnings: 
    animationImportErrors: 
    animationImportWarnings: 
    animationRetargetingWarnings: 
    animationDoRetargetingWarnings: 0
    importAnimatedCustomProperties: 0
    importConstraints: 0
    animationCompression: 1
    animationRotationError: 0.5
    animationPositionError: 0.5
    animationScaleError: 0.5
    animationWrapMode: 0
    extraExposedTransformPaths: []
    extraUserProperties: []
    clipAnimations: []
    isReadable: 0
  meshes:
    lODScreenPercentages: []
    globalScale: 1
    meshCompression: 0
    addColliders: 0
    useSRGBMaterialColor: 1
.
.
.
```

 guid 뒤에 ModelImporter, materials, animations, meshes 설정 등 FBX 파일 특유의 임포트 세팅 정보가 추가로 붙어 있는 것을 볼 수 있다.



정리하면 **메타파일을 주로 구성하는 요소들은 다음과 같다:**

- **fileFormatVersion**: .meta 파일의 형식 버전 번호
- **GUID**: 에셋의 고유 식별자 (쉽게 말해 이 에셋의 주소. 다른 에셋이나 씬에서 참조할 때 이 값으로 연결됨)
- Importer 설정
  - 텍스처 에셋의 경우 : TextureImpoprter
  - 모델의 경우 : ModelImporter
  - 스크립트의 경우 : MonoImporter


사실 개발 중에는 대부분 에디터에서만 작업하기 때문에 아티스트가 메타파일을 직접 들여다볼 일이 거의 없다. 그런데 이 파일이 진짜 중요한 순간은... 에셋을 팀원과 주고받거나 Git 같은 버전 관리 시스템을 쓸 때다. 메타파일을 잘 모르면 예상치 못한 충돌이있을 수 있기 때문에 내가 작업한 것을 커밋할 때는 꼭 잘 알고 챙겨야 하는 숨은 ‘필수 파일’이다.





### 유니티에서 작업한 파일을 커밋해보자

**✅ 반드시 .meta 파일도 함께 커밋해야 한다**

보통 에셋 자체를 수정할 때(예: 버텍스 정보나 텍스처 컬러 변경)에는 커밋에 png, fbx 같은 원본 파일이 올라온다.
그런데 유니티 에디터에서 임포트 세팅만 바꾼 경우(예: 텍스처 크기, 노멀맵 여부 등), 커밋창에 뜨는 건 바로 .meta 파일이다. 마찬가지로 파일을 하나 복사해 새로 추가한 파일을 기존 파일 이름으로 바꾸고, 기존 파일을 다른 폴더에 옮기는 경우에도 .meta 파일이 커밋창에 잡힌다. 

하지만 Unity에서 .meta 파일이 잡혔을때 이 파일의 역할을 모르고 잘못 커밋하거나 빠뜨리고 커밋하면 다음과 같은 문제가 발생한다:

1. **GUID 에러**: 다른 팀원이 풀받을 때 새로운 GUID가 생성되어 참조가 깨짐

   ​	GUID 에러가 발생하면 **Missing Reference** 에러가 발생하면서 프리팹이나 씬에서 에셋을 찾지 못함
2. **수정한 임포트 설정 포함 X**: 텍스처 압축, 모델 설정 등이 기본값으로 초기화



**Unity용 .gitignore 예시:**

```gitignore
# Unity generated
[Ll]ibrary/
[Tt]emp/
[Oo]bj/
[Bb]uild/
[Bb]uilds/
[Ll]ogs/
[Uu]ser[Ss]ettings/

# Never ignore .meta files
!*.meta

# OS generated
.DS_Store
.DS_Store?
._*
Thumbs.db
ehthumbs.db

# Visual Studio / MonoDevelop generated
ExportedObj/
.vs/
/*.csproj
/*.unityproj
/*.sln
/*.suo
/*.user
/*.userprefs
/*.pidb
/*.booproj
```







## 2. Unreal Engine의 .uasset 시스템

### 2.1 .uasset 파일이란?

Unreal Engine은 **바이너리 기반의 .uasset 파일 시스템**을 사용한다. 에셋의 데이터와 메타데이터가 하나의 바이너리 파일에 통합되어 저장된다.

```
Content/
├── Characters/
│   ├── Hero_BP.uasset          ← 블루프린트 (바이너리)
│   ├── Hero_Mesh.uasset        ← 스태틱 메시 (바이너리)
│   └── Hero_Material.uasset    ← 머티리얼 (바이너리)
├── Textures/
│   ├── Hero_Diffuse.uasset     ← 텍스처 데이터 + 메타데이터
│   └── Hero_Normal.uasset
```

### 2.2 .uasset의 특징

**장점:**

- **빠른 로딩**: 바이너리 형태로 최적화되어 에디터 로딩 속도가 빠름
- **데이터 무결성**: 에셋과 메타데이터가 하나의 파일에 있어 분리될 위험이 없음
- **압축 효율성**: 바이너리 형태로 저장되어 파일 크기가 작음

**단점:**

- **머지 불가능**: 바이너리 파일이므로 충돌 시 자동 머지가 불가능
- **diff 어려움**: 유니티와 다르게 파일 변경 내용을 텍스트로 확인할 수 없음
- **부분 수정 어려움**: 작은 변경사항도 전체 파일을 다시 저장





### 2.3 Unreal Engine에서 Git/SVN 사용 시 주의사항

**Unreal용 .gitignore 예시:**

```gitignore
# Unreal Engine generated files
Binaries/
DerivedDataCache/
Intermediate/
Saved/
Build/

# OS generated
.DS_Store
Thumbs.db

# IDE generated
.vs/
.vscode/
*.sln
*.vcxproj
*.vcxproj.filters

# Only track .uasset and .umap files in Content
Content/**
!Content/**/*.uasset
!Content/**/*.umap

# Source code
Source/
```







## 3. 실제 작업 시나리오별 비교

### 3.1 텍스처 수정 시나리오

**Unity에서 텍스처 임포트 설정 변경:**

```
수정 전:
├── Character_Diffuse.png (변경 없음)
└── Character_Diffuse.png.meta (설정 변경됨)

Git status:
modified: Assets/Textures/Character_Diffuse.png.meta

커밋 내용:
- 텍스처 압축 형식을 DXT1에서 DXT5로 변경
- 최대 해상도를 1024에서 2048로 증가
```

**.meta 파일의 변경 내용 (텍스트로 확인 가능):**

![image-20250708224156038](./../images/2025-07-08-.meta%20vs%20.uasset/image-20250708224156038.png)

```diff
- textureFormat: 10  # DXT1
+ textureFormat: 12  # DXT5
- maxTextureSize: 1024
+ maxTextureSize: 2048
```

![image-20250708224815532](./../images/2025-07-08-.meta%20vs%20.uasset/image-20250708224815532.png)

현재 작성중인 깃 포스트를 VScode 내 git 기능을 통해 바뀐 모습을 확인





**Unreal Engine에서 동일한 작업:**

```
수정 전후:
└── Character_Diffuse.uasset (전체 파일 변경)

Git status:
modified: Content/Textures/Character_Diffuse.uasset

커밋 내용:
- 바이너리 파일이므로 구체적인 변경 내용을 텍스트로 확인 불가
- 커밋 메시지에 직접 작성: "텍스처 압축 설정 및 해상도 변경"
```



VScode로 uasset을 열어보면,

![image-20250708225936295](./../images/2025-07-08-.meta%20vs%20.uasset/image-20250708225936295.png)



https://filext.com/ko/online-file-viewer.html

<a href="https://filext.com/ko/online-file-viewer.html">online-file-viewer</a>

![image-20250708230341862](./../images/2025-07-08-.meta%20vs%20.uasset/image-20250708230341862.png)



### 3.2 팀 협업 충돌 상황

**Unity에서의 충돌 해결:**

```
상황: 두 명의 아티스트가 같은 텍스처의 임포트 설정을 동시에 수정

Artist A: 압축 형식 변경
Artist B: 필터링 모드 변경

충돌 파일: Character_Diffuse.png.meta

해결 방법:
1. .meta 파일을 텍스트 에디터로 열기
2. 두 변경사항을 모두 적용하여 수동 머지
3. Unity 에디터에서 확인 후 커밋
```

**Unreal Engine에서의 충돌 해결:**

```
상황: 두 명의 아티스트가 같은 텍스처를 수정

충돌 파일: Character_Diffuse.uasset

해결 방법:
1. 바이너리 파일이므로 자동 머지 불가능
2. 한 버전을 선택하거나
3. 작업을 다시 수행해야 함
```



| 왜 언리얼 uasset은 머지가 안될까?                            |
| ------------------------------------------------------------ |
| Unity와 Unreal의 가장 큰 차이점이 바로 여기에 있다.<br/>Unity .meta 파일 (텍스트 형식):<br/>yaml# 실제 .meta 파일 내용을 텍스트로 볼 수 있음<br/>fileFormatVersion: 2<br/>guid: 3c8d9f2e1a4b5c6d7e8f9g0h1i2j3k4l<br/>TextureImporter:<br/>  mipmaps:<br/>    mipMapMode: 0<br/>    enableMipMap: 1<br/>  textureFormat: 1        ← 이 부분만 변경됨을 확인 가능<br/>  maxTextureSize: 2048<br/>Unreal .uasset 파일 (바이너리 형식):<br/>hex dump:<br/>89 50 4B 47 00 00 00 00 E3 3C C4 A6 00 00 00 00<br/>7B 1A F6 E3 C8 AB 5F A6 00 00 00 00 E9 03 00 00<br/>16 00 00 00 2F 47 61 6D 65 2F 4D 61 70 73 2F 54<br/>...바이너리 데이터가 계속...<br/><br/>※ 사람이 읽을 수 없고, 어떤 부분이 변경되었는지 <br/>   확인할 수 없다.<br/>이런 차이 때문에:<br/><br/>Unity: 충돌 시 텍스트 편집기로 양쪽 변경사항을 확인하고 수동으로 합칠 수 있다<br/>Unreal: 바이너리 데이터라서 무엇이 바뀌었는지 알 수 없고, 머지도 불가능하다 |



## 5. 실무에서 자주 발생하는 문제와 해결책

### 5.1 Unity "Missing Reference" 문제

**문제 상황:**

```
Console에 나타나는 에러:
"The referenced script on this Behaviour (Game Object 'Player') is missing!"
```

**원인:**

- .meta 파일이 커밋되지 않아 GUID가 변경됨
- 스크립트 파일이 이동되었지만 .meta 파일이 동기화되지 않음

**해결방법:**

```bash
# 1. 전체 프로젝트 다시 클론
git clone [repository] fresh-project
cd fresh-project

# 2. 또는 Library 폴더 삭제 후 재생성
rm -rf Library/
# Unity 에디터에서 프로젝트 열기 (Library 자동 재생성)

# 3. .meta 파일 강제 재생성
# Unity > Assets > Reimport All
```

### 5.2 Unreal Engine 에셋 손상 문제

**문제 상황:**

```
에디터에서 나타나는 에러:
"Asset 'Character_BP' failed to load because it references missing or invalid asset"
```

**원인:**

- .uasset 파일이 부분적으로 손상됨
- 의존성 에셋이 삭제되었지만 참조가 남아있음

**해결방법:**

```bash
# 1. 에셋 검증
# Unreal Editor > Content Browser > Validate Assets

# 2. 참조 확인
# 에셋 우클릭 > Reference Viewer

# 3. 손상된 에셋 복구
git checkout HEAD~1 -- Content/Characters/Character_BP.uasset
# 또는 백업에서 복원
```


## 6. 마무리: 엔진별 최적 워크플로우

### Unity 팀을 위한 일일 워크플로우

```
작업 중:
1. 새 에셋 추가 시 즉시 .meta 파일과 함께 add
2. 임포트 설정 변경 시 해당 .meta 파일 변경사항 확인
3. 정기적으로 git status로 변경사항 점검

1. 관련 에셋과 .meta 파일을 함께 커밋
```

### Unreal Engine 팀을 위한 일일 워크플로우

```
아침 시작 시:
1. git pull origin main
2. 에디터에서 Content Browser 새로고침
3. 에러 로그 확인 및 충돌 에셋 점검

작업 중:
1. 작업 전 팀원들과 겹치는 에셋 여부 확인
2. 큰 변경사항은 별도 브랜치에서 작업
3. 바이너리 파일 특성상 작은 단위로 자주 커밋

작업 완료 시:
1. 관련 에셋들을 패키지 단위로 커밋
2. 상세한 커밋 메시지로 변경사항 기록
3. 다른 팀원들에게 주요 변경사항 공지
```

**`.meta`** = 외부 파일용 **경량 GUID + Import 설정 컨트롤러**. 텍스트-친화적이라 Git에 이점.

**`.uasset`** = 데이터와 메타가 합쳐진 **자급식 패키지**. Redirector·Cooker로 참조 일관성·배포 자동화.

협업 규모·VC 방식·배포 정책에 따라 두 방식은 장단이 분명하므로, 아트·TA·DevOps가 함께 파이프라인을 설계해야 ‘잃어버린 참조’, ‘충돌 병합’, ‘빌드 통합’ 리스크를 최소화할 수 있다.

