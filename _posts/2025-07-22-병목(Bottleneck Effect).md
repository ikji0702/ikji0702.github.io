---
title: '병목(Bottleneck Effect)'
parmalink : /study/2025-07-22
date: 2025-07-22
tags:
  - Optimization
  - Com2us TA Campus
---

> GPU, CPU 병목과 Compute Shader & Render Graph 맛보기





## 병목

![image-20250722064857212](./../images/2025-07-22-%EB%B3%91%EB%AA%A9(Bottleneck%20Effect)/image-20250722064857212.png)

당연히 한자어일 거라고 생각했는데, 뜻을 찾아보니 사실은 **‘Bottleneck effect’**라는 영어 표현을 그대로 직역한 것이었다.

실제로 병을 생각해보면, 병의 목 부분은 병의 몸통보다 훨씬 좁아 액체가 한 번에 쏟아지지 않도록 막아주는 역할을 한다. 따라서 병의 크기와 상관없이, 액체가 흘러나오는 양은 항상 좁은 병목의 크기에 의해 일정하게 제한된다. 이렇게 특정 요소(병의 목)의 한계로 인해 전체 성능이 제한되는 상황을 **병목 현상(bottleneck effect)**이라고 부른다.

이 개념을 게임 분야에서는 시스템의 성능이 저하되고 프로세스의 전체 효율이 떨어지는 상황을 말한다. 게임에서는 보통 특정 기능이나 작업이 데이터를 집중적으로 사용하거나 과부하 상태가 되면, 해당 부분이 전체 시스템의 성능을 끌어내리는 원인이 된다. 즉, 하나의 제한적인 요소 때문에 디바이스가 가지고 있는 최대 성능을 온전히 발휘하지 못하는 것이다.

흔히 우리는 CPU 병목 현상, GPU 병목 현상 같은 표현을 자주 사용한다. 그렇다면 이러한 표현들은 보통 어떤 상황에서 사용될까?



## CPU 병목

![image](./../images/2025-07-22-%EB%B3%91%EB%AA%A9(Bottleneck%20Effect)/image.png)

CPU는 게임에서 일종의 **머리** 역할을 한다. 복잡한 의사 결정이나 수많은 연산들을 처리하고, 그 결과물을 GPU로 넘겨주는 역할을 수행한다. 따라서 CPU 병목은 주로 **계산이 매우 많거나 복잡할 때** 발생한다.

CPU가 원활히 작동하기 위해선, GPU에 지속적으로 충분한 데이터를 제공할 수 있어야 한다. 예를 들어, PC 게임을 기준으로 설명하면, 일반적으로 게임 데이터는 SSD나 HDD와 같은 스토리지에 저장된다. 이 데이터는 RAM을 통해 CPU와 GPU로 전달되는데, 만약 CPU가 데이터를 처리하는 속도가 느리다면 GPU에게 제때 데이터를 넘기지 못하는 상황이 발생한다. 이렇게 되면 GPU는 자신의 작업을 이미 모두 끝냈음에도 CPU가 다음 데이터를 전달할 때까지 기다려야 하며, 이는 결국 GPU의 성능을 충분히 활용하지 못하게 되는 **병목 현상**으로 이어진다.

게임에서는 이러한 상황이 빈번히 발생할 수 있는데, 예를 들어, 수백 개의 NPC가 동시에 경로를 찾으려 할 때, 물리 엔진이 수십 개의 오브젝트 간 충돌을 동시에 계산할 때, 혹은 엄청나게 많은 파티클 시스템이 복잡한 수학 연산을 수행할 때와 같이, 다양한 시나리오가 CPU의 작업량을 폭발적으로 증가시킬 수 있다. 이때 CPU가 이 모든 연산을 빠르게 처리하지 못한다면, 게임의 전체적인 로직 속도는 느려지고, 사용자에게 즉각적으로 체감될 정도로 성능이 저하된다.

즉, CPU는 스토리지에서 RAM을 거쳐 GPU에 이르는 과정 속에서 쉬지 않고 데이터를 주고받으며 균형을 유지하려고 부단히 노력하고 있는 것이다.



## GPU 병목

![image (1)](./../images/2025-07-22-%EB%B3%91%EB%AA%A9(Bottleneck%20Effect)/image%20(1).png)

반대로, CPU가 전달하는 엄청난 양의 데이터를 GPU가 충분히 빠르게 처리하지 못할 때는 **GPU 병목** 현상이 발생할 수 있다.

GPU(그래픽 카드)는 화면에 물체를 그리는 일을 담당한다. CPU는 물체의 위치, 형태, 광원과의 상호작용 등 여러 가지 정보를 계산하여 GPU에 넘겨주고, GPU는 전달받은 데이터를 기반으로 최종적인 화면 이미지를 렌더링한다. 이 모든 과정이 끝나면 한 프레임이 완성된다.

이 렌더링 작업은 매 프레임 반복적으로 일어난다. 예를 들어, 게임이 초당 60프레임(60fps)을 목표로 한다면, CPU와 GPU가 함께 하나의 프레임을 처리하는 데 걸리는 시간이 약 **16.7ms(1000ms ÷ 60fps)** 이하로 유지되어야 자연스럽고 부드러운 움직임을 보여줄 수 있다. 만약 GPU가 이 시간을 초과하여 데이터를 처리하게 된다면, GPU 병목 현상으로 인해 게임의 프레임 속도가 떨어지고, 화면이 끊기거나 지연되는 현상이 발생하게 된다.





#### ➕메모리 병목

메모리, 특히 RAM에서 발생하는 병목 현상도 결코 간과할 수 없다. RAM 용량과 대역폭은 시스템 전반의 데이터 처리 속도에 지대한 영향을 미치며, 성능 병목의 주요 원인 중 하나로 작용한다.



![image (2)](./../images/2025-07-22-%EB%B3%91%EB%AA%A9(Bottleneck%20Effect)/image%20(2).png)

<u>*(RTX 4080 기준 메모리 대역폭 716.8gb, **1080 대비 2.24배 /** FP32 (float) 48.74 TFlops, **1080 대비 5.49배)***</u>

최근 들어 메모리 병목 문제가 더욱 두드러지고 있는 이유는, CPU와 GPU는 지속적으로 발전하고 있는 반면, 메모리 기술의 발전 속도는 상대적으로 더딘 편이기 때문이다.

예를 들어, 요즘 고사양 게임들은 기본적으로 **4K 해상도**를 지원하며, 이에 따라 **고해상도 텍스처**, **복잡한 지형 데이터**, **실시간 조명 정보** 등 대용량의 데이터를 빠르게 불러오는 것이 필수가 되었다.

특히 **원신**처럼 방대한 오픈월드 게임에서는 플레이어가 고속으로 맵을 탐험하면서 **전혀 새로운 지역의 리소스를 실시간으로 로딩**해야 하는 일이 빈번하다. 이 과정에서 메모리 대역폭이 부족하거나 RAM 용량이 충분하지 않으면, 순간적인 **로딩 지연**이나 **프레임 드랍**이 발생하게 된다.





| 💡이러한 현상을 병목 현상을 조금이나마 해결하기 위한 레벨 디자인 적 솔루션들 |
| ------------------------------------------------------------ |
| ![image (3)](./../images/2025-07-22-%EB%B3%91%EB%AA%A9(Bottleneck%20Effect)/image%20(3).png)<br /><a href="https://www.youtube.com/watch?v=ixllGOX0Evw&t=8056s">https://www.youtube.com/watch?v=ixllGOX0Evw&t=8056s</a><br />갓 오브 워 라그나로크에서는 플레이어가 좁은 틈 사이를 통과하는 구간이 등장한다. 이때 화면의 약 70% 이상이 거대한 바위로 가려지며 시야가 급격히 좁아진다. 이는 단순한 연출이 아니라, 플레이어의 시선을 제어하면서 그 뒤편에서 다음 월드를 로딩할 시간을 벌기 위한 디자인 장치다. 별도의 로딩 화면을 보여주지 않으면서도 매끄러운 월드 전환을 가능하게 해주는 대표적인 레벨 디자인 기반 최적화 기법이다.<br /><br /><br />![image (4)](./../images/2025-07-22-%EB%B3%91%EB%AA%A9(Bottleneck%20Effect)/image%20(4).png)<br /><a href="https://www.youtube.com/watch?v=ihQn01iKErA">https://www.youtube.com/watch?v=ihQn01iKErA</a><br />비슷한 사례는 **젤다의 전설: 왕국의 눈물**에서도 찾아볼 수 있다.<br/><br/>이 게임에 등장하는 **트레루프**라는 능력은, 플레이어가 수직 벽을 관통해 윗 공간으로 이동할 수 있게 해주는 기술이다. 캐릭터는 벽을 뚫는 동안 마치 물속을 헤엄치듯 천천히 부유하는데, 이 연출이 단지 시각적 표현이 아니라는 것이 최근 스위치 2 발매 이후 알게 되었다.<br/><br/>스위치 1세대에서는 이 트레루프 연출이 비교적 길게 유지되었는데, 이는 실제로 **위쪽 공간을 로딩하기 위한 시간을 벌기 위한 장치**였다는 뜻이 된다. 반면 **스위치 2의 성능 향상**으로 인해 해당 장면의 처리 속도가 크게 빨라졌고, 결과적으로 **연출 시간 자체가 짧아지는 현상**이 나타났다.<br/><br/><br />위 두 사례 모두, **로딩을 눈에 보이지 않게 감추는 방식**으로 설계된 것으로 단순히 연출처럼 보이지만 사실은 **최적화된 리소스 전환을 위한 시간 확보 장치**로 작동하는 것. 이는 레벨 디자인과 하드웨어 성능, 그리고 사용자 경험이 절묘하게 맞물려 작동하는 좋은 예시다.</a> |



이러한 병목 현상을 줄이기 위해 우리는 다양한 방법을 이미 알고 있다.

- Batching
- GPU Instancing
- Culling
- LOD
- Computer Shader

이 중 평소 좀 못 들어본 내용들에 대해 더 알아보는 시간을 가졌다.

Computer Shader와 Render Graph에 대해 가볍게 훑어볼 예정인데, 두 가지 모두 좀 내용을 정리해본 결과 아티스트가 사용할 일은 전혀(…) 없을 것으로 판단되며 프로그래머와의 더 친밀한 관계를 위한 단어 알아둠 정도로 생각하면 좋을 것 같다.





## Compute Shader 살짝 핥아보기 😋

컴퓨트 셰이더(Compute Shader)는 간단히 말해, **GPU에게 그래픽 이외의 연산 작업까지 시킬 수 있도록 확장된 기능**이다. 본래 GPU는 **동일한 작업을 대량의 데이터에 병렬 처리**할 수 있는 구조 덕분에, 주로 화면에 무언가를 그리는 렌더링 작업에 사용되어 왔다.

하지만 컴퓨트 셰이더는 이러한 GPU의 병렬 처리 능력을 렌더링 외의 **범용 계산(general-purpose computation)**에도 활용하기 위해 도입된 기능이다. 이를 흔히 **GPGPU(General Purpose computing on GPU)**라고 부른다. (지피지피유.. 어감이 귀여운데)

컴퓨트 셰이더는 2009년, **DirectX 11의 일부로 Direct3D 11 API에서 처음 공식 도입**되었고, 이후 **OpenGL 4.3 (2012년)**에서 지원되기 시작했다.

유니티에서는 `Create > Shader > Compute Shader` 메뉴를 통해 프로젝트 내 에셋으로 쉽게 생성할 수 있으며, 파일 확장자는 `.compute`이다. DirectX11 스타일의 **HLSL 언어로 작성**되며, 다른 셰이더들과 마찬가지로 GPU에서 작동하지만, **렌더링 파이프라인과는 완전히 독립적으로 작동**한다는 점이 가장 큰 특징이다.

### **일반적인 그래픽스 파이프라인**

```
Vertex Shader → Tessellation → Geometry Shader → Rasterization → Pixel Shader
```

- 고정된 순서로 실행
- 입력/출력이 정해진 구조

### 컴퓨트 셰이더

```
독립적 실행 → 임의의 메모리 접근 → 자유로운 데이터 구조
```

- 렌더링 파이프라인과 무관
- 범용 연산(GPGPU) 목적

### ✅ **장점**

- **대규모 병렬 처리**: GPU의 가장 큰 강점 중 하나다. 수백~수천 개의 코어를 활용해 병렬 연산을 수행할 수 있어, 경우에 따라서는 CPU보다 훨씬 빠른 속도를 낼 수 있다.

  특히 **행렬 연산**, **이미지 처리**, **물리 시뮬레이션**처럼 반복적이고 대량의 데이터 처리가 필요한 작업에 적합하다.

### ❗ **하지만**

- **프로그래밍 난이도가 높다**: 렌더링 파이프라인에 대한 깊은 이해가 필요하고, 디버깅 환경이 제한적이라 버그를 찾고 수정하기가 쉽지 않다.
- **모든 작업에 유리한 것은 아니다**: 병렬 연산에 특화된 구조이기 때문에, 연산 순서가 중요한 작업에는 오히려 비효율적일 수 있다. 또한 처리할 데이터가 적은 경우, 초기 설정과 호출 비용 때문에 오히려 손해가 될 수 있다.

**컴퓨트 셰이더는 '적재적소'에 써야 하는 도구다.**

무작정 사용한다고 해서 이득이 되는 것이 아니며, 잘못 사용할 경우 오히려 성능이 떨어지고 복잡도만 증가할 수 있다. 정확한 용도와 상황을 판단한 후에 도입하는 것이 중요하다.







## 유니티 Render Graph 살짝 핥아보기 😋

최신 그래픽 엔진에서는 GPU 리소스를 사용자가 직접 생성한 힙(heap)의 메모리 위치에 배치할 수 있는 기능을 제공하고 있다.

렌더 그래프를 살펴보기 전에, 먼저 “렌더링 엔진을 왜 파이프라인이라고 부를까?”라는 질문을 던져보자.

그 이유는, 그래픽 렌더링 과정이 순차적인 여러 단계를 거쳐 처리되는 구조이기 때문이다.
 ‘파이프라인(pipeline)’이라는 단어 자체가 데이터를 연속적으로 처리하는 구조를 뜻하며, 그래픽 렌더링에서도 이 흐름은 버텍스 처리 → 기본 도형 생성 → 래스터화 → 픽셀 처리 → 프래그먼트 병합 등으로 이어진다. 이 일련의 과정이 공장의 컨베이어 벨트처럼 일직선으로 연결되어 있다고 생각하면 이해가 쉽다.

Unity에서는 Built-in Render Pipeline, Universal Render Pipeline처럼 이름부터 파이프라인을 강조하고 있다. 반면, Unreal Engine은 ‘파이프라인’이라는 명칭을 브랜딩에는 사용하지 않으며, 복수의 렌더 파이프라인을 선택하는 대신 하나의 통합된 렌더링 시스템을 제공한다. 이로 인해 유니티처럼 분리된 파이프라인 개념을 엔진 구조에서 직접적으로 볼 수는 없다.

렌더링 과정 중 특정 단계에서 생성된 리소스는 대부분 소수의 다른 단계에서만 사용된다. 예를 들어, **포스트 프로세싱의 블룸 패스**는 다음 렌더 단계인 톤 매핑에서만 그 결과물을 사용하며, 프레임의 다른 영역에서는 필요하지 않다.

이러한 특성을 활용하면 메모리 최적화를 위한 “앨리어싱(Aliasing)” 기법을 사용할 수 있다. API를 통해 메모리 앨리어싱을 설정하면, 리소스의 타입이나 이름은 중요하지 않고 **크기와 메모리 주소**만 기준으로 삼아 배치할 수 있다.

이는 미리 리소스를 한번 할당하는 것보다 더 효율적으로 메모리를 활용할 수 있는 방법이다. 즉, **사용 시점이 겹치지 않는 여러 리소스를 동일한 메모리 공간에 겹치듯 배치함으로써**, 전체 사용 메모리를 줄이고 성능 저하를 방지할 수 있다.



![image (5)](./../images/2025-07-22-%EB%B3%91%EB%AA%A9(Bottleneck%20Effect)/image%20(5).png)

**Render Graph(또는 Frame Graph)**는 복잡한 화면 렌더링 과정을 효율적으로 관리하기 위한 설계 방식 중 하나다.
 건물을 짓기 전에 전체 설계도를 그리는 것처럼, 렌더링에 필요한 모든 작업을 하나의 큰 그림으로 설계하고 흐름을 구성하는 개념이라고 이해할 수 있다.

Direct3D12, Vulkan 같은 **차세대 그래픽스 API**에서는 렌더링 작업을 수행할 때 리소스의 상태 전환이나 종속성(Dependency)을 개발자가 수동으로 관리해야 하는 경우가 많다. 그러나 Render Graph를 사용하면 이러한 작업 대부분을 **자동으로 처리**할 수 있다.

각 렌더 패스(render pass)에서 프로그래머는 해당 패스에서 어떤 리소스를 사용할 것인지 명시한다.
 예를 들어 셰이더 입력 버퍼, 렌더 타겟, 깊이-스텐실 버퍼 등 다양한 리소스들이 이에 해당한다.

렌더 그래프는 이와 같은 리소스 간의 관계를 파악하여, 각 패스의 실행 순서를 최적화하고 **필요한 리소스 상태 전환과 배치**를 자동으로 구성해준다.

![image (6)](./../images/2025-07-22-%EB%B3%91%EB%AA%A9(Bottleneck%20Effect)/image%20(6).png)

![image (8)](./../images/2025-07-22-%EB%B3%91%EB%AA%A9(Bottleneck%20Effect)/image%20(8).png)

위 이미지처럼, 예를 들어 리소스 A는 3번째 패스까지만 사용되고, 리소스 C는 4번째 패스부터 사용된다면 이 둘은 **사용 시점이 겹치지 않기 때문에** 동일한 GPU 메모리를 공유할 수 있다.
이와 같은 개념은 리소스 A와 D 사이에도 적용되며, **리소스 수명 주기를 고려한 메모리 재사용**이 가능해진다.

또한, 프레임 단위로 사용되는 리소스들, 이른바 **일시적 리소스(Transient Resources)**도 존재한다.
예를 들어, 카메라의 뎁스 버퍼나 디퍼드 라이팅에서 사용되는 G-Buffer와 같은 리소스가 해당된다.
이러한 리소스는 주로 렌더 그래프 외부의 시스템(엔진 내부 로직)에 의해 소유되므로, 그래프 내에서는 그 상태만 추적·관리하는 용도로 제한적으로 사용된다.





![image (9)](./../images/2025-07-22-%EB%B3%91%EB%AA%A9(Bottleneck%20Effect)/image%20(9).png)

이 이미지는 GDC 2024에서 유니티 6가 발표한 **렌더 그래프(Render Graph)** 관련 강연 중 일부이다.

유니티는 그동안 SRP Batcher처럼 드로우콜을 줄이기 위해 많은 메시를 같이 묶어 그리는 인스턴싱 같은 기술들을 도입해 왔다. 그러나 이런 방식의 시도가 많았지만, **CPU가 담당하는 렌더링 처리 작업이 획기적으로 줄어들지는 않았다.**

이에 대한 해결책으로, 렌더 그래프는 단순히 GPU에게 렌더링 부담을 떠넘기는 방식이 아닌, **각 렌더링 단계에서 버퍼와 텍스처가 어떻게 활용되는지 시각적으로 파악하고 제어할 수 있는 방식**을 제공하기 위해 유니티에선 렌더 그래프라는 기능을 소개하게 되었다.

렌더 그래프 에디터에서는 특정 버퍼를 우클릭하면 그 버퍼를 사용하는 **패스와 서브패스 정보**, 그리고 해당 패스가 어떤 역할을 하는지에 대한 **정의까지 확인**할 수 있다. 이를 통해 **중복되거나 불필요한 패스를 병합하거나 최적화**할 수 있어, 전체 렌더 파이프라인의 효율을 높이는 데 기여한다.





![image (10)](./../images/2025-07-22-%EB%B3%91%EB%AA%A9(Bottleneck%20Effect)/image%20(10).png)

위 이미지의 위쪽 부분(**Before: 3 render passes - No pass merging**)은 최적화되지 않은 상태로서 렌더링이 3개의 독립적인 패스(JRP Render Objects, Copy Shader, Effect Shader)로 나뉘어져 있어 각 단계마다 타일 메모리와 시스템 메모리 간의 데이터 복사가 빈번하게 발생하고 있다. 이로 인해 많은 메모리 사용과 성능 저하가 생길 수 있다.

아래쪽 부분(**After: 1 render pass - Post-processing on tiles**)은 렌더링 패스를 하나로 통합하여 포스트 프로세싱 과정을 타일 단위로 수행하는 최적화 방식을 보여준다. 각 단계에서 발생하던 데이터 복사가 크게 줄어들어 프레임당 약 **32MB**의 메모리를 절약할 수 있게 되었다고 설명하고 있다.





언리얼 엔진에서도 비슷한 최적화 개념을 적용하고 있으며, 이에 대한 자세한 내용은 다음 공식 문서에서 확인할 수 있다: 
 👉 [Rendering Dependency Graph (UE4.27)](https://dev.epicgames.com/documentation/en-us/unreal-engine/rendering-dependency-graph?application_version=4.27)

유니티의 Render Graph 시스템 역시 활발히 개발 중이며, 작성일 기준 단 **3일 전에도 업데이트가 공유**될 만큼 최근까지도 지속적으로 개선되고 있다. (관련 커뮤니티 토론)
 👉 [Render Graph updates in Unity 6.3](https://discussions.unity.com/t/render-graph-updates-in-unity-6-3/1668122)







# 결론

사실 이런 기술들 외에도, 지금은 **AI가 상상을 초월할 속도로 발전하고 있는 시대**다. 그래서 앞으로의 최적화 트렌드가 어떤 방향으로 흘러갈지는, 솔직히 말해 아티스트 입장에서 단정짓기 어려운 것이 현실이다.
하지만 **이전보다 훨씬 더 혼자서 많은 것을 시도할 수 있는 환경이 갖춰졌고**, 과거엔 상상조차 어려웠던 일들이 지금은 AI 덕분에 마법처럼 가능해졌다.

![image (11)](./../images/2025-07-22-%EB%B3%91%EB%AA%A9(Bottleneck%20Effect)/image%20(11).png)

한때 큰 화제를 모았던 프레임 생성 기술 꽉꽉이씨의 경우... (꽉꽉이 아님, 스팀 페이지 : <a href="https://store.steampowered.com/app/993090/Lossless_Scaling/">Lossless Scaling</a>)
이제는 **4K 해상도**와 **120Hz 이상의 고주사율 모니터**가 많은 유저들에게 일상적인 환경이 되었고, 사람들은 그만큼 더 높은 프레임, 더 선명한 화질에 집착하게 되었다. 하지만 게임이나 영상에서 항상 일정한 품질을 유지하는 건 기술적으로 쉽지 않기 때문에 이를 보완해주는 유틸리티 프로그램들이 등장했고, 이 중 하나인 로스리스 스케일링 프로그램도 한동안 큰 인기를 끌었다.



이 외에도 <a href="https://demo.dynamicslab.ai/chaos">**Mirage AI** </a>같은 신기술은 앞으로의 콘텐츠 제작 방식을 근본부터 바꿔놓을 가능성이 크다. Mirage는 Dynamics Lab에서 개발한 실시간 AI 게임 생성 엔진으로, 유저가 키보드, 컨트롤러, 또는 **자연어 프롬프트**만으로도 게임 환경과 상호작용을 생성할 수 있다.
예를 들어, 단순히 “도시를 혼란스럽게 만들어줘”, “해안선을 따라 질주하고 싶어” 같은 문장을 입력하는 것만으로도, **완전히 새로운 게임 경험을 실시간으로 플레이**할 수 있게 되는 것이다.





우리는 최적화를 위해 단순히 버텍스와 텍스처를 줄이고, 드로우콜을 낮추는 것만 신경 쓸 것이 아니라 결국 "**어떤 흐름을 어디서 제어할 것인가**"에 포커스를 맞춰야 한다.

앞의 AI 기술들 처럼 앞으로 우리는 더 이상 고전적인 최적화 기술만을 배우는 것에 그치지 않고, **변화하는 기술 트렌드와 새로운 기능들에 유연하게 적응하고, 새로운 방향에서 최적화를 고민하는 자세**가 필요하다.
이 모든 변화 속에서 도태되지 않기 위해선 꾸준히 공부하고 실험하고... 흐름을 관찰하는 습관이 우리에게 큰 무기를 쥐어줄 것이다.









- 참고문헌

  해당 글은 컴투스 TA실에서 준비한 TA 캠퍼스 8주차 게임 최적화 자료를 참고해 작성되었습니다.

  https://logins.github.io/graphics/2021/05/31/RenderGraphs.html#placed-resources

  https://www.inven.co.kr/webzine/news/?news=294168

  https://www.cnblogs.com/xiaoniuhululu/p/18628127

  https://www.corsair.com/kr/ko/explorer/gamer/gaming-pcs/what-is-pc-bottlenecking/?srsltid=AfmBOoqq963CBx0mXQ6FW4MAGDerhFDYNkqFS8_vsRgs2OcN2k-B45D7

  https://marcus-story.tistory.com/214
