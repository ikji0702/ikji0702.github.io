---
title: '프로파일러랑 친해지기 1단계'
parmalink : /study/2025-07-29
date: 2025-07-29
tags:
  - Profiling
  - Com2us TA Campus
---

&nbsp;

&nbsp;

&nbsp;

## 유니티 프로파일러

**게임의 전반적인 성능을 실시간으로 모니터링하고 분석하는 도구이다.** 주로 CPU와 GPU 사용량 분석, 총 메모리 사용량과 GC(가비지 컬렉터) 발생을 모니터링 하는데 사용된다. 외에도 Physics나 Networking 항목들로 물리 연산 비용을 분석하고 네트워크 데이터 전송량과 성능 측정 등 다양한 항목을 프로파일링 가능하다.

&nbsp;

**이럴때 사용하자!**

→ 프레임 드롭이 발생할때

→ 성능 병목(이상) 지점을 찾을 때

→ 지속적인 성능 모니터링을 할 때

| GC (Garbage Collector)                                       |
| ------------------------------------------------------------ |
| **사용하지 않는 메모리를 자동으로 해제하는 메모리 관리 시스템**.<br />C# 스크립트에서 new 키워드로 객체 생성 시 힙메모리에 할당하고, 참조가 끊어지면 이를 ‘가비지’처리함. 이런 가비지 데이터들을 주기적으로 정리하는 기능을 가비지 컬렉터, 줄여서 GC라고 칭함. 보통 힙 메모리가 부족하거나, 일정 시간이 경과되었을때 실행된다. System.GC.Collect() 함수를 호출해 원하는 타이밍에 호출도 가능하다.<br/><br/>이야기만 들어선 좋아보이는 이 기능은 생각보다 프레임 드롭에 많은 영향을 끼치는데, GC가 실행중 되고 있을 때 모든 스레드가 일시정지되기 때문에 보통 1-5ms정도 소요된다 (성능마다 차이를 보임) → 60fps 기준 16.67ms가 기본으로 사용되기 때문에 1-5ms는 결코 작은 단위는 아니다. 뿐만 아니라 빈번한 GC 발생은 CPU 사용량 증가로 이어질 수 있다.<br/><br/>이걸 최적화 할 수 있을까? 오브젝트 풀링 : 자주 생성 / 파괴되는 객체들을 미리 생성해두고 재사용해 참조가 끊어지는 일이 없도록 하는것, 총알이나 파티클, UI 요소에 적용하면 좋다.<br/><br/>참고 : Unity의 Incremental GC 간단하게 말하자면 시간 분할 처리 하는 GC를 말한다. 프레임마다 최대 2ms씩 GC 작업을 수행해 GC 작동의 가장 큰 문제인 프레임 드롭 현상을 크게 감소시킨다. |

&nbsp;

&nbsp;

&nbsp;

## 프레임 디버거

**한 프레임이 어떻게 렌더링 되는지, 그 과정을 단계별로 분석하는 도구.** 주로 Draw Call 분석(Batch가 잘 되는지)이나 오브젝트가 어떤 타이밍에 그려지는지에 사용된다.

&nbsp;

**이럴때 사용하자!**

→ 드로우 콜이 너무 많을때…

→ 파이프라인 최적화 지점을 찾을때

→ 셰이더나 메티리얼 문제를 확인할 때

→ 대부분의 렌더링 이슈 확인

&nbsp;

&nbsp;

&nbsp;

## 메모리 프로파일러

**메모리 사용량을 자세하게 분석하고, 메모리 누수가 어디에서 발생하는지 찾을때 사용하는 도구**다. 스냅샷으로 특정 프레임 시점의 메모리 상태를 캡처하고 비교할 수 있다. 오브젝트 별 차지하는 메모리 량 뿐만 아니라 스크립트의 메모리 할당 상황도 확인 할 수 있다.

&nbsp;

**이럴때 사용하자!**

→ 메모리 사용량이 지속적으로 증가할 때

→ 메모리가 부족한데 어떤 걸 최적화 해야하는지 모를때

&nbsp;

&nbsp;

| **Throttling**                                               |
| ------------------------------------------------------------ |
| **지나치게 발열이 발생할 때 의도적으로 기기 성능을 떨어뜨리는 것. 보통 모바일 기기에서 많이 발생**한다.<br/><br/>- 일반적으로 CPU의 스로틀링은 90~100°C 부근에서 발생한다고 한다. 대부분의 Intel/AMD 최신 프로세서는 90°C를 넘어서면 보호 차원에서 성능을 자동으로 낮춘다. 그래픽카드(GPU)는 85~95°C에서 스로틀링이 시작되며, 엔비디아·AMD 주요 모델 대부분 95°C 이상에서 제한이 걸린다.<br/>- 모바일 기기는 40~50°C에서 스로틀링을 시작하는 경우가 많고, 심할 때는 55°C~60°C에 가까워지면 성능 저하가 확연히 나타난다.<br/>- 최신 스마트폰 AP의 경우 실제 벤치마크(예: Snapdragon 8 Gen 1, Exynos 2100 등)에서 50°C에 도달하면 성능이 15~30%까지 급격히 저하되고, 가끔 더 낮은 온도에서도 제한되는 경우가 발생한다.<br/>- PC보다 모바일 쪽이 쿨링 같은 기능이 많이 부족하고, 기기 손상이 더 쉽게 일어나기 때문에 모바일이 더 낮은 온도에서 스로틀링을 시작한다.<br /><br /><img src="./../images/2025-07-29-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC%EB%A7%81%EC%9D%B4%EB%9E%91%20%EC%B9%9C%ED%95%B4%EC%A7%80%EA%B8%B0%201%EB%8B%A8%EA%B3%84/image.png" alt="image" style="zoom: 50%;" /><br />발열 관련 스로틀링은 디바이스에 큰 관심이 없는 나도 알고 있을 정도로 유저들이 신경쓰는 부분인데, 정말 성능이 극단적으로 제한되기 때문에 예민하게 반응할 수 밖에 없는 문제인 것 같다. 발열 관리… |

&nbsp;

&nbsp;

&nbsp;

&nbsp;

## 도전! 프로파일링

이왕 프로파일러에 대해 배웠는데, 실제로 문제가 되는 상황을 개선해보고 싶어서 한동안 눈가리고 살았던 하늘섬 게임 토론장을 켰다… 안 본 사이에 화가 난 유저들이 많았다.

</br>

![image (3)](./../images/2025-07-29-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC%EB%A7%81%EC%9D%B4%EB%9E%91%20%EC%B9%9C%ED%95%B4%EC%A7%80%EA%B8%B0%201%EB%8B%A8%EA%B3%84/image%20(3).png)

![image (1)](./../../../../Downloads/image%20(2).png)

![image (1)](./../images/2025-07-29-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC%EB%A7%81%EC%9D%B4%EB%9E%91%20%EC%B9%9C%ED%95%B4%EC%A7%80%EA%B8%B0%201%EB%8B%A8%EA%B3%84/image%20(1)-1753722138671-6.png)

&nbsp;

&nbsp;

&nbsp;

이 사람들이 말하는 할아버지가 뭐냐면… 게임 초반부에 유저에게 무기를 지급하는 대왕 장로 캐릭터가 있는데, 유독 이 친구를 만나 대화하면 게임이 멈춘다는 글이 많았다.

</br>

<img src="./../images/2025-07-29-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC%EB%A7%81%EC%9D%B4%EB%9E%91%20%EC%B9%9C%ED%95%B4%EC%A7%80%EA%B8%B0%201%EB%8B%A8%EA%B3%84/image%20(4).png" alt="image (4)" style="zoom:50%;" />

무기를 받을때 문제가 된다는걸 보니 무기 객체를 생성하는 부분에서 문제가 있는 것 같은데, 일단!

&nbsp;

&nbsp;

&nbsp;

&nbsp;

### 😭 문제가 되는 부분의 성능 파악</br>

![image (5)](./../images/2025-07-29-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC%EB%A7%81%EC%9D%B4%EB%9E%91%20%EC%B9%9C%ED%95%B4%EC%A7%80%EA%B8%B0%201%EB%8B%A8%EA%B3%84/image%20(5).png)

평균 22ms(이것도 높긴 하네…)를 유지하다가, 무기를 소환하는 순간, **CPU와 GPU 모두 60ms대로 스파이크가 튀는 것을 발견했다**. ...이제는 알 수 있다. 정말 놀라운 수치가 아닐 수 없다.

16.67ms로 60fps이 동작한다고 생각 했을때, 순간적이지만 69.33ms는 결과적으로 약 14fps로 동작한다는 뜻이다.

&nbsp;

&nbsp;

&nbsp;

### 😾 그래서 뭐가 문제인가</br>

![image (6)](./../images/2025-07-29-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC%EB%A7%81%EC%9D%B4%EB%9E%91%20%EC%B9%9C%ED%95%B4%EC%A7%80%EA%B8%B0%201%EB%8B%A8%EA%B3%84/image%20(6).png)

일단 종합적으로 다 문제처럼 보이긴 하는데, 정말 많이 호출되고 많이 보이는 키워드들이 있다.

- Shader.EditorLoadVariantFromCache
- Shader.CompileGPUProgram
- File.Open

이 친구들은 왜이렇게 많이 호출이 되는 것인가.

찾아보니 이 세 함수들은 모두 셰이더와 리소스 로딩과 관련된 작업이었다. **Shader.EditorLoadVariantFromCache**는 대표적으로 동적 메테리얼(new Material()) 호출, 또는 셰이더 키워드 변경(’EnableKeyword()’ / ‘DisableKeyword()’) 호출시 발생한다. **Shader.CompileGPUProgram**은 캐시에 없는 새로운 셰이더 베리언트를 사용할때 주로 발생한다.  File.Open은 키워드 그대로 리소스를 로딩할때 사용된다. 에셋을 임포트 하거나 컴파일된 셰이더를 읽어올때나…

(세 가지 모두 에디터에서 발생하는 문제가 아닌가? 빌드시엔 셰이더들을 사전 컴파일 하기 때문에 에셋 로딩으로 인한 스파이크는 에디터에서만 발생하는 문제가 아닐까… 짧게나마 이렇게도 생각해봄)

&nbsp;

&nbsp;

| 한 프레임에서 메인, 렌더 스레드가 딱 맞춰 일을 하네...?      |
| ------------------------------------------------------------ |
| TA 캠퍼스 9주차 자료를 보면, 위와 같이 GPU가 CPU의 일이 끝나기를 기다리는 형태에선 GPU가 다음 프레임까지 이전 프레임에서 받은 일을 하고 있는 그림이 있는데, 위 이미지를 보면 메인 스레드가 GPU가 일을 다하기를 기다리고 일이 다 끝나야지만 다음 프레임을 시작하는 것을 볼 수 있다.<br/><br/>이럴 때 Multi-threaded Rendering을 활성화해 문제를 해결 할 수 있다. (CPU의 메인 스레드와 렌더 스레드를 분리해 병렬 처리하는 방식.)<br/><br/>- 해당 옵션을 켜려고 찾아봤는데, 멀티스레드 렌더링 옵션이 Unity 2020 부터 강제로 Always On이 되었다고 한다. 그렇다면 해당 기능이 활성화 되어 있는데 왜 GPU가 일을 다 끝낼때까지 메인스레드가 기다리는가.. 궁금하다.. 🫠 |

&nbsp;

결론적으로 검색+현재 프로젝트 상태를 생각했을때 가장 문제되는 점은 일단, 너무 많은 드로우콜. 그리고 셰이더 베리언트 인 것 같다. 불투명 오브젝트도 많고 후처리 효과도 많고 하다보니… new로 생성하는 세 종의 무기(+셰이더 1종) + 생성 이펙트(+셰이더 3종) + 화면 전체를 덮는 이펙트들이 문제가 아니었을까?

&nbsp;

&nbsp;

&nbsp;

&nbsp;

### 😱 드로우콜은 왜 이렇게 많지? </br>

![image-20250729020420969](./../images/2025-07-29-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC%EB%A7%81%EC%9D%B4%EB%9E%91%20%EC%B9%9C%ED%95%B4%EC%A7%80%EA%B8%B0%201%EB%8B%A8%EA%B3%84/image-20250729020420969.png)

이미지만 보고는 유니티 터레인에게 배신 당한줄 알았다.

&nbsp;

사실 우리가 만든 식생의 종류는 그렇게 많지 않은데, 왜 이렇게 드로우콜이 높은가 프레임 디버거로 확인해봤더니 오브젝트도, 그림자도 모두 식생 하나하나 그리고 있는 것을 발견하였다.

하늘섬은 공중에 떠있는 섬이라는 컨셉을 가지고 있어 여러 개의 지면 메쉬를 하나의 씬에서 사용하는데, 여러개의 터레인을 사용하기도 하고, 또 유니티 터레인의 LOD 시스템 때문에 여러 격자로 나누어져 그려지는 방식 두개가 결합 되어 결과적으로 드로우콜을 올리는데 굉장히 큰 영향을 끼친 것 같다.

실제로 프레임 디버거로 그려지는 과정을 보면 터레인 영역별로 식생이 묶여 그려지기는 하는데, 그 영역 자체가 너무 좁고 많아 마치 개별로 식생을 하나하나 그리는 듯 하였다… 유니티 터레인에서 관리되는 구역(청크라고도 함) 크기를 조절 할 수 없다면 이를 개별 메쉬로 export해 Static 배칭이 되도록 하는 것이 최선의 방법이라고 생각된다.

&nbsp;

&nbsp;

&nbsp;

## 결론

시간이 부족해 실제 개선 작업까지 진행하진 못했지만, 이번 분석을 통해 적잖은 충격을 받았다.

일단 가장 충격적이었던 건 무기 지급같은 간단한 단일 이벤트 연출 하나가 전체 프레임을 14fps까지 떨어뜨릴 정도로 심각한 성능 저하를 일으키고 있었다는 점이었다…

분석을 통해 원인을 좀 파악해보니, 일단 이 게임은 1. 셰이더 컴파일 및 동적 로딩으로 인한 지연과 2. 예상보다 지나치게 많은 드로우콜이 가장 큰 문제인 것 같다. 단순하게 그래픽이 굉장히 성능에 많은 (안좋은) 영향을 끼치고 있겠다 싶긴 했는데, 실제로 수치로 마주하니 프로그래머에게 미안한 마음이 드는 순간이었다.

유니티 프로파일링 공부에도 많은 도움이 되었지만, 일단 오랜만에 유저들이 남긴 글도 찾아보고… 이전에 작업했던 파일들도 까보며 잠깐 잊었었던 개발자의 마음을 다시 불어 일으켜주는 소중한 시간이었다.

&nbsp;

&nbsp;

&nbsp;

&nbsp;

&nbsp;

&nbsp;
