---
title: '아티스트는 고민해야 한다-메모리 편'
parmalink : /study/2025-06-01-1
date: 2025-06-01
tags:
  - Optimization
  - Com2us TA Campus
---

> 너무 많은 디바이스에 너무 많은 리소스들을 맞춰야 하는 앞으로의 아티스트들의 과제 

- [디바이스](#----)
  * [시대의 변화](#------)
    + [**하드웨어 세대 비교 (2000 vs 2020)**](#--------------2000-vs-2020---)
    + [**디바이스의 변화에 따른 최적화 변화**](#-----------------------)
      - [메모리 관리](#------)
  * [게임이 사용할 수 있는 메모리 공간](#-------------------)
- [최적화 기법](#------)
  * [메모리 최적화](#---------)
    + [Unity : Memory Profiler](#unity---memory-profiler)
      - [실습](#--)
    + [해상도 동적 스케일](#----------)
      - [👀 Dynamic Resolution Scaling 사용 사례를 찾아보다가...](#---dynamic-resolution-scaling-------------)
  * [최적화 사례](#------)
    + [텍스처 압축](#------)
  * [아티스트를 돕는 최적화 툴](#-------------ux--)
    + [텍스처 사용 정보를 시각적으로 보여주는 엔진 툴](#--------------------------)
      - [언리얼 엔진 - Straming Pool](#---------straming-pool)



아티스트에게 '최적화'라는 단어만큼 무겁고 어렵게 느껴지는 말은 없을 것이다.

아티스트로서 작업에 몰입하다 보면 늘 심미성과 성능 퍼포먼스 사이에서 고민하게 된다. 실제로 유저에게 첫 반응을 이끌어 내는 것은 눈에 보이는 리소스이고 그에 따른 경험이다. 하지만 점점 게임들이 다양한 디바이스를 모두 지원하고 또, 한 프로젝트에 포함하는 컨텐츠의 양도 급격히 많아지는 시대가 오면서 이제는 **'게임을 아름답게 만드는 것'** 만큼, **'효율적인 에셋 관리로 무겁지 않은 그래픽을 만드는 것'**도 중요한 화두로 자리잡았다.

2000년대 초반만 해도, 우리가 다루는 텍스처와 모델의 버텍스는 기기 한계가 명확했기 때문에 사용할 수 있는 폼이 정해져 있었고, 콘솔이나 PC 모바일까지 각각 하드웨어 예산이 너무나도 달라 하나의 디바이스를 타겟팅해 그 안에서 예쁘게 만드는 것이 숙제였다. 하지만 2020년대에 들어서면서 하드웨어 스펙은 기하 급수적으로 성장하게 되었고, AAA 게임은 수십 GB 데이터를 불러와 유저에게 보여준다. 이제는 '메모리가 부족해서 못 넣는다'가 아니라, '메모리가 남아 돌아도, 돌리는 방식에 따라 언제든 병목이 터질 수 있다'라는 것을 늘 염두해 둬야 하는 것이다.

</br>

</br>

# 디바이스

## 시대의 변화

내가 처음 ‘게임을 만들어보고 싶다’는 생각을 한 건 2017년이다. 그때 공부에 사용했던 툴은 Visual Studio 2014와 Unity 2017 버전. 2017년의 유니티는 빌트인 렌더 파이프라인에 셰이더 그래프도 없던 시절이라 지금 생각해보면 정말 쉽지 않은 툴이었다.

게임 개발을 처음 시작한 지 어느덧 8년. 사실 그렇게 긴 시간은 아니지만 그 사이 업계는 너무나 많은 게 바뀌었다.

### **하드웨어 세대 비교 (2000 vs 2020)**

| 디바이스            |           | 2000년대 사양        | 2020년대 사양                  |
| ------------------- | --------- | -------------------- | ------------------------------ |
| **플레이 스테이션** | CPU       | 294MHz               | 3.5GHz (약 12배 증가)          |
|                     | RAM       | 32MB                 | 16GB (약 500배 증가)           |
| **PC**              | CPU       | Pentium 4(단일 코어) | 고성능 프로세서(8-16코어)      |
|                     | RAM       | 256~512BM            | 32~64GB(약 100배 ~ 200배 증가) |
|                     | GPU       | GeForce 3/4          | RTX 40시리즈 (VRAM 24GB)       |
| **모바일**          | CPU       | 104MHz ARM           | 3.78GHz 6코어 (약 200배 향상)  |
|                     | RAM       | 6MB                  | 8GB (약 100배 증가)            |
|                     | 화면 크기 | 176x208 LCD          | 2556x1179 OLED                 |

</br>

위 표를 비교해봤을때 20년 사이에

1️⃣ 플레이 스테이션은 CPU 성능이 약 12배, 메모리는 500배 증가하면서 DVD 드라이브에서 SSD로 전환하며 하드웨어 레이트레이싱을 지원하기 시작했으며 2️⃣ PC는 CPU와 RAM도 큰 변화가 있었지만 그래픽 카드에서 가장 뛰어난 성능 향상을 보여주었다. 3️⃣ 모바일의 변화또한 굉장히 극적인데, 화면의 크기 변화도 주목할 만 하지만, 모바일도 하드웨어 레이 트레이싱을 지원하면서 스마트폰에서도 콘솔급 성능을 보여줄 수 있게 되었다. 

RAM의 성장만 그래프로 표현했을때,

<img src="./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image%20(1).png" alt="image (1)" style="zoom:50%;" />

그래프만 봐도 알 수 있듯, 지난 20년 사이 PC, 콘솔, 모바일 모두 RAM 용량이 상상할 수 없을 만큼 커졌다. 하지만 이 변화는 단순히 “용량이 늘었다”는 수준을 훨씬 넘어선다. 이제는 각 플랫폼이 메모리를 쓰는 방식부터, 최적화에서 신경 써야 할 포인트 자체가 완전히 달라진 것이다.

아티스트 입장에서도 **“메모리가 많으니 그냥 막 써도 된다”는 착각이 오히려 더 큰 문제를 만들 수 있다**는 점을 꼭 기억해야 한다. 많아진 메모리만 믿고 무심코 작업하다 보면, 예기치 못한 메모리 낭비나 퍼포먼스 이슈가 오히려 더 자주 터질 수 있기 때문이다.

</br>

| 여기서 질문, RAM vs VRAM                                     |
| ------------------------------------------------------------ |
| **RAM (Random Access Memory)**<br />RAM은 시스템 메모리로, CPU가 직접 접근하여 운영체제와 애플리케이션이 사용하는 주메모리입니다. 프로그램 실행, 데이터 처리, 멀티태스킹 등 컴퓨터의 전반적인 작업을 담당합니다. CPU와 메인보드에 직접 연결되어 있으며, 시스템 전체의 성능에 직접적인 영향을 미칩니다.<br /><br />**VRAM (Video Random Access Memory)**<br />VRAM은 그래픽 전용 메모리로, GPU(그래픽 처리 장치) 내부에 위치하여 그래픽 관련 데이터만을 처리합니다. 텍스처, 프레임 버퍼, 셰이더 데이터 등 3D 렌더링과 화면 출력에 필요한 정보를 저장합니다. GPU에 물리적으로 가까이 위치하여 그래픽 처리에 최적화된 높은 대역폭을 제공합니다.<br /><br />처리 속도 측면에서 CPU보다 GPU가 더 나은 것처럼 VRAM이 RAM보다 그래픽 작업에 특화되어 더 빠른 처리속도를 갖고 있다. 하지만 접근성 측면에선 RAM은 CPU와 GPU 모두 가능하지만, VRAM은 주로 GPU만 접근이 가능하다. (용량은 일반적으로 RAM이 VRAM보다 훨씬 크다.)<br />게임에서는 두 메모리 모두 중요하다. RAM이 부족할 시 시스템 전체가 느려지고 VRAM이 부족할 시 텍스처 품질 저하나 프레임 드롭이 발생한다. 특히 최신 게임은 그래픽 퀄리티(주로 해상도)가 대폭 상승하면서 그 중요도가 높아졌기 때문에 충분한 VRAM 용량을 중요시 여기게 되었다. |

</br>

</br>

### **디바이스의 변화에 따른 최적화 변화**

특히 2020년대에 들어서면서 ‘메모리 관리’는 그 어느 때보다 중요한 이슈가 됐다.
이제는 단순히 예산만 맞춘다고 끝나는 게 아니라 장시간 플레이와 라이브 서비스 환경에서 생기는 메모리 누수나 조각화가 실제 크래시로 이어지는 일이 부쩍 많아졌다. 최근의 게임 엔진들은 툴과 프로파일러에서 메모리 관리를 직접 지원하고 있다.

#### 메모리 관리

| **엔진**    | **대표 기능**                                                | **활용 포인트**                                              |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Unreal 5    | Low-Level Memory Tracker, MemReport, 샘스마트 포인터(SharedPtr) | 각 플랫폼이나 태그별로 메모리 상황을 따로 저장하고, 핫로딩(리소스 교체) 이후 얼마나 메모리가 더 쓰였는지 쉽게 비교할 수 있음 |
| Unity 2022+ | Memory Profiler 패키지 + Leaks 워크플로                      | 스냅샷을 비교해서 어떤 오브젝트가 메모리를 많이 쓰는지 찾아내고, 자동으로 C# 영역과 네이티브 영역(엔진 내부)의 사용량을 나눠서 보여줌 |
| 콘솔 SDK    | PS5 DevKit “GPA Memory Binning”, XSX PIX 메모리 시각화       | 전체 메모리를 여러 구역으로 나눠 관리하고, 실시간 구조(RT Acceleration Structure)가 조각나거나 비효율적으로 배치되는지 쉽게 확인할 수 있음 |

</br>

</br>

## 게임이 사용할 수 있는 메모리 공간

**런처블 크래시** *(launch crash, 게임이나 앱에서 실행(launch) 하자마자 곧바로 발생하는 크래시(비정상 적인 종료, 충돌)를 뜻함. 로고, 타이틀, 로딩창에서 발생하는 크래시들. 주요 원인은 과도한 메모리 사용으로 인한 리소스 불러오기 실패의 경우가 많다.)* 방지를 위해 기기 전체 RAM의 1/4~1/3 이내로 잡는 것이 안정적이다. 특히 모바일의 경우 백그라운드에서 실행되고 있는 앱이 많을 수록 메모리 사용량이 증가하기 때문에 게임 프로젝트의 메모리 스트리밍/해제 설계가 중요하다. 

2025년 기준 게임 개발 평균 가이드라인을 GPT에게 물어봤을때 권장 선은 다음과 같은 답변을 얻을 수 있었다. 

| 플랫폼          | RAM/VRAM (2025 기준) | 권장 텍스처 예산(런타임) |
| --------------- | -------------------- | ------------------------ |
| PC (구형)       | 2GB VRAM             | 1~1.2GB                  |
| PC (보급형)     | 4GB VRAM             | 2~2.5GB                  |
| PC (최신)       | 8GB+ VRAM            | 3~4GB+                   |
| 모바일 (저사양) | 2GB RAM              | 200~350MB                |
| 모바일 (중상급) | 4~6GB RAM            | 400~700MB                |
| 모바일 (최신)   | 8GB+ RAM             | 800MB~1.2GB              |

</br>

실제로, 

[윈도우11에서의 RAM사용량에 대한 분석글]: https://www.digitaltrends.com/computing/how-much-ram-does-windows-11-use/

 을 보았을때

- **8GB RAM 시스템**: Windows 프로세스가 2GB-4GB 이상 사용
- **32GB RAM 시스템**: 8GB-10GB까지 사용

한다고 표기하고 있다. 이는 8GB RAM 시스템에서 게임이 실제로 사용할 수 있는 메모리가 4-6GB에 불과하다는 것을 의미한다. 따라서 8GB를 최소 사양으로 설정하는 게임들조차 실제로는 매우 제한적인 메모리 예산 내에서 작동해야 한다는 사실을 보여주고 있다. 

</br>

</br>

</br>

----

# 최적화 기법

## 메모리 최적화

### Unity : Memory Profiler

**Unity Memory Profiler**는 게임이 실행 중일 때의 화면을 캡처해 그 순간의 메모리 상태를 그대로 나타내준다. 이렇게 저장한 캡처샷을 통해 사용되는 메모리, GPU, 그래픽 리소스 등을 각 탭별로 분석할 수 있고, VRAM 초과 같은 다양한 문제를 공식적으로 진단해주는 툴이다.

</br>

#### 실습

그래서 이번에는 내가 가진 가장 큰 프로젝트를 대상으로 Unity Memory Profiler를 직접 돌려봤다.

*(참고로 이 프로젝트는 대학생 팀 프로젝트로, 최적화는 거의 신경 쓰지 않고 만든 케이스..😓)*

![image-20250608202044980](./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608202044980.png)

현재 이 게임은 Steam에 올라가 있고, 권장 사양은 8GB 이상의 GTX 960 PC다.
사실 이 사양도 테스트 여유가 없어서, 작업실에서 가장 낮은 성능 컴퓨터로 돌려본 뒤 기록한 최소 사양이다.

![image-20250608201956720](./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608201956720.png)

위 이미지는 게임 플레이 시 가장 처음 나오는 장면에서 메모리 프로파일러를 캡처한 결과다.

전체 메모리 사용량은 약 7GB. 스팀에 명시된 권장 사양에는 맞추긴 했지만, Managed Heap(1.23GB)와 Objects(0.94GB)만 해도 모두 C#에서 생성된 오브젝트와 데이터여서 예상 외의 부분에서 꽤 많은 메모리가 쓰이고 있다는 걸 알 수 있었다.

</br>

<img src="./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608205705796.png" alt="image-20250608205705796" style="zoom: 67%;" />

리소스 항목을 좀 더 들여다보면, Texture2D와 RenderTexture가 도합 2.22GB로 전체 메모리의 약 32%를 차지하고 있었다. (Texture2D 1460장, RenderTexture 174개) 여기서 제일 큰 비중을 차지한 건 라이트맵이었는데, 한 장당 42MB에 달하는 이미지가 10장 넘게 사용되고 있었다.

![image-20250608205931034](./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608205931034.png)![image-20250608205939893](./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608205939893.png)

“어? 이상하다, 라이트맵은 4장만 구웠었는데?” 하고 다시 확인해보니, 실제로는 directional light, light, shadowmask 등 총 3가지 타입별로 4종류의 라이트맵이 만들어졌고, 결국 한 장에 5MB짜리 라이트맵이 12장씩이나 쓰이고 있었다.

</br>

</br>

| 실제 라이트 맵은 5MB 하는데, 왜 메모리 프로파일러에선 42MB로 나오는가? |
| ------------------------------------------------------------ |
| <img src="./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608210909826.png" alt="image-20250608210909826" style="zoom: 67%;" /><br />디스크에 저장된 텍스처 파일은 5.3MB(DXT5/BC3 압축 기준) 정도로 작아 보인다.<br/> 하지만 이건 어디까지나 압축된 용량일 뿐, 실제로 게임이 실행될 때는 압축이 풀리면서 훨씬 더 큰 메모리를 차지하게 된다.<br /><br />예를 들어 2048×2048 RGBA 텍스처 한 장이 있다고 치자.<br/>압축이 모두 풀리면 2048 × 2048 × 4바이트(RGBA) = 약 16.78MB<br/>이게 바로 '한 장'의 실제 픽셀 데이터가 차지하는 메모리다. 외에도, 실제 게임에선 원본 텍스처만 사용하는게 아니라 여러 해상도의 밉맵을 자동으로 생성해 함께 사용한다. 예를 들어 원본 2048의 16.78MB 이미지가 있다고 가정했을때, <br />밉맵1(1024): 4.19MB<br />밉맵2(512): 1.05MB<br />밉맵3(256): 0.26MB<br />...이런 식으로 쭉 내려가면, 밉맵까지 모두 더하면 약 22.4MB가 된다.<br /><br />외에도, 라이트맵처럼 HDR 데이터를 사용하는 경우엔 일반 텍스처보다 훨씬 더 큰 포맷(16비트, 32비트)이 적용되면서 예상보다 훨씬 더 많은 메모리를 차지할 수 있다.<br /><br />그래서 에디터에선 5MB밖에 안돼 보이던 텍스처가 실제로 메모리에선 20~40MB, 그 이상까지 점유할 수도 있다. 때문에 텍스처 하나를 가볍게 보면 안되는 이유이기도 하다. |

</br>

</br>

</br>

</br>

---

### 해상도 동적 스케일

**‘해상도 동적 스케일’(Dynamic Resolution Scaling, DRS)이란?**

GPU 부하가 일정 한계(예: 16.6 ms/60 fps)를 넘으면 실시간으로 렌더 타깃 해상도를 낮췄다가, 여유가 생기면 다시 올려 프레임률을 안정시키는 적응형 렌더링 기법이다. 모바일처럼 전력·발열 제한이 큰 플랫폼에서 필수로 자리잡았다.

– 해상도는 0.5 × ~ 1.0 × 네이티브(50 % ~ 100 %) 범위를 보통 사용하고, 업스케일(Linear/FSR/Temporal)을 거쳐 화면에 출력하는 방식이다.

scaleFactor 가 0.8이면 1080p 단말에서 864p로 내부 렌더링을 하고, 이후 업스케일·AA(안티 엘리어싱) 후 화면엔 1080p로 표시하는 것이다.

```mathematica
1)  프레임-타이밍 측정
2)  scaleFactor 조정 (예: 0.05 단위)
3)  렌더 목표 해상도 = 원본 × scaleFactor
4)  3D 렌더링  →  업스케일( TAAU / FSR / 빌리니어 )  →  HUD 합성
```

</br>

</br>

</br>

#### 👀 Dynamic Resolution Scaling 사용 사례를 찾아보다가...

##### 원신의 Dynamic Character Resolution 기능?

DRS 기능을 유저가 on/off 할 수 있도록 설정창에 빼놓은 경우가 없는지 찾아보다가, 2024년 원신(Genshin Impact) 4.4 업데이트 내역에서 캐릭터 동적 해상도 기능이 플레이 스테이션에 도입되었다는 글을 찾을 수 있었다.

![image-20250608214715778](./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608214715778.png)

*이미지 출처 :https://genshin.hoyoverse.com/en/news/detail/122141<br>Dynamic Character Resolution에 대한 글 : https://game8.co/games/Genshin-Impact/archives/442438*

하지만 원신에서 제공하는 Dynamic Character Resolution 기능은 캐릭터 전용 업스케일 기능으로 품질 개선의 목적이 있는 기능으로 일반 DRS처럼 성능 확보 목적이 있다고 보기는 힘들다. 실제로 해당 기능을 끌 때 성능 개선에 더 도움이 된다는 이야기가 많았으며, 특히 저사양 기기에서 해당 기능을 활성화 했을 때 프레임 드랍이나 프레임 속도가 느려진다는 유저들의 이야기가 많았다.

<img src="./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/dynamic-character-resolution-on-and-off-v0-a6lr24n8dpfc1.jpeg" alt="r/Genshin_Impact - 동적 캐릭터 해상도 켜기 및 끄기" style="zoom:67%;" />

*이미지 출처 : *

[https://www.reddit.com/r/Genshin_Impact/comments/1af945b/dynamic_character_resolution_on_and_off/]: https://www.reddit.com/r/Genshin_Impact/comments/1af945b/dynamic_character_resolution_on_and_off/	"https://www.reddit.com/r/Genshin_Impact/comments/1af945b/dynamic_character_resolution_on_and_off/"

*<br> 해당 기능을 켰을 때 캐릭터 폴리곤 모양이 부드럽게 처리되는 모습 확인 가능.*

이는 원신의 Dynamic Character Resolution 기능이 폴리곤의 계단 현상을 완화시키기 위해 AA(Anti-Aliasing)을 사용하면서 발생한 문제로 확인된다. 

</br>

</br>

----

## 최적화 사례

### 텍스처 압축

#### 텍스처 메모리 다이어트

위의 개인 프로젝트의 메모리 프로파일러를 살펴 보더라도, 게임 메모리를 대부분 차지하는 리소스는 2D 텍스처라는 사실을 알 수 있다. 그렇기 때문에 2D 텍스처가 많이 사용되는 스프라이트 애니메이션 게임들은 텍스처 메모리를 과도하게 사용할 수 밖에 없고, 이는 특히 모바일 기기에서 심각한 성능 이슈를 일으킬 수 있다. 

그래서 보통은 텍스처들을 한데 묶어서 관리하는 아틀라스(Atlas) 기법을 적극적으로 활용하지만, 이 방식 역시 빈 공간이 생기면서 메모리가 낭비되는 문제가 있어 완벽한 해결책이라고 보긴 어렵다.

</br>

GDC 2018에서 텍스처 메모리에 대한 최적화에 대해 설명한 사례가 있어 이를 알아보고자 한다.

<A href="https://gdcvault.com/play/1025419/By-Grabthar-s-Hammer-What">GDC 2018 - By Grabthar&#39;s Hammer, What a Savings: Making the Most of Texture Memory with Sprite Dicing</A>

나이트 인 더 우즈를 개발한 개발사 Secret Lab는 게임을 PC에서 IOS로 포팅하는 과정에서 해결한 메모리 최적화 문제에 대해 이야기하고 있다. PC 버전을 개발할 땐 4GB 메모리에 맞춰 게임을 만들었지만, IOS 기기중 가장 사양이 낮은 기기는 1GB의 메모리를 사용하고 있었고 실제로 앱이 사용 가능한 메모리 공간은 600MB에 불과했다. 때문에 게임 메모리를 차지하는 대부분의 리소스인 스프라이트 이미지를 어떻게든 압축할 필요가 생겼다. 

<img src="./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608225426959.png" alt="image-20250608225426959" style="zoom:50%;" /><img src="./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608225451170.png" alt="image-20250608225451170" style="zoom:50%;" />

*이미지 출처 : GDC 2018 - By Grabthar's Hammer, What A Savings.*

이 문제를 해결하기 위해 **Sprite Dicing**이라는 기능을 개발했다고 한다. 이 기능은 **스프라이트를 작은 조각들로 분할한 후, 동일한 부분을 식별하여 중복을 제거**하는 것이다. 예를 들어, 캐릭터의 여러 감정 표현에서 신체 부분은 동일하고 얼굴 표정만 다른 경우, 공통된 신체 부분은 한 번만 저장하고 변화하는 얼굴 부분만 별도로 관리하는 것이다. 이를 통해 나이트 인더 우즈의 대부분의 텍스처는 아틀라스의 활용도를 극대화하면서도 메모리 낭비를 최소화 할 수 있었다.

이 기능을 통해 주인공 캐릭터 Mae의 Run 스프라이트 애니메이션은 23개의 720*720 스프라이트로 압축할 수 있었고, 이는 2.68MB의 원본 리소스를 1.5MB까지 줄일 수 있었다. (원본의 55%)

<img src="./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250609000943273.png" alt="image-20250609000943273" style="zoom:50%;" />

Sprite Dicing은 움직이지 않는 부분이 많은 물체에 대해서 훨씬 더 나은 성능을 보여줬는데, 침대 애니메이션(담요가 펄럭거리는)에서는 원본 9.76MB에서 1.5MB로 원본의 15%정도로 텍스처를 압축할 수 있었다.

</br>

다만 이 방식은, 하나의 큰 스프라이트를 여러 개의 작은 조각으로 쪼개다 보니 각 조각마다 별도의 UV 좌표가 필요하다. 결국 2D 게임임에도 불구하고 유니티에서 메시 렌더러를 활용할 수밖에 없었다. 폴리곤 수가 늘어나는 부담이 있긴 했지만, 개발팀은 메모리 절약 효과가 훨씬 크다고 판단해 Sprite Dicing + Mesh renderer 방식을 사용하였다.

</br>

</br>

## 아티스트를 돕는 최적화 툴

사실 아티스트가 이런 세세한 부분까지 신경 쓰면서 작업하는 건 현실적으로 거의 불가능하다고 생각한다.
 아티스트는 본질적으로 심미적 관점에 더 집중하게 마련이고, 기술적 최적화나 메모리·GPU 같은 제약까지 일일이 챙기기란 쉽지 않다. 아무래도 성향 자체가 다르고, 작업 우선순위도 다르기 때문에 이런 부분이 자연스럽게 뒤로 밀리게 된다.

그렇다고 프로그래머나 TA팀이 아트팀에서 올리는 리소스를 전부 하나하나 검수하는 것도 마찬가지로 비현실적이다. 리소스 수 자체가 많고, 그때그때 기준도 바뀌니 사람 손만으로는 한계가 있을 수밖에 없다.

결국 가장 현실적이면서도 유연한 워크플로우는, **아티스트가 심미성에 집중하면서도, 메모리·발열·GPU 병목 같은 제약이 ‘자동으로 시각화’되는 구조를 만드는 것**이라고 본다. 즉, ‘사람이 검수하는 게 아니라 파이프라인이 자동으로 체크’하는 방식. TA가 최적화 규칙과 기준을 만들고 그에 따른 도구나 대시보드 형태로 리소스에 대한 실시간 피드백이 제공되면 아티스트는 자연스럽게 문제를 발견하고 개선하려 노력할 것이다.

</br>

<A href="https://www.gdcvault.com/play/1024418/Efficient-Texture-Streaming-in-Titanfall">GDC 2017 - Texture Streaming in Titanfall 2</a>

타이탄폴 2 게임은 멀티플레이, 세미 오픈월드 게임이다. PS4, XBO, PC에서 60 fps 4K 텍스처 유지를 목표로 하며 VRAM 3GB, HDD 40BM/s 환경에서 이를 만들어야 했다. 여기서 팀에서 추가로 건 제약은 아티스트 텍스처 최적화 수작업 금지.이다. 아티스트가 텍스처 최적화에 신경 안 써도 되는 자동 시스템을 만드는 것이 타이탄폴2를 개발한 Respawn의 목표였다.

Respawn은 툴이 대신 최적화해야한다는 철학으로

- 아티스트는 작업만 하고,
- 자동 스트리밍 시스템 + 시각적 피드백

을 이야기 했는데, 여기서 설명하는 **자동 텍스처 스트리밍**이란,

- 게임 맵을 16비트 크기 타일로 나누고, 각 타일에 프로브 카메라를 설치한다. GPU가 이 카메라들을 보는 장면을 큐브맵으로 렌더링하고 이 렌더링된 밉맵의 사용률을 **히스토그램(픽셀 분포)**로 기록한다.
- 그리고 .stbsp 파일로 4*4 타일 묶음의 데이터 페이지로 패킹하고, 밉맵 정보중 중요한 512개만 저장해 압축한다.
- 그래서 플레이 할땐 플레이어가 있는 영역과 보이는 곳만 계산하고, 중요한 텍스처는 더 선명하게, 덜 중요한건 해상도 낮게 출력한다.

이 최적화 방식은 타일·히스토그램 사전 계산을 빌드 서버가 처리하면서 아트팀은 리소스만 올려도 텍스처가 자동 관리되도록 처리해 대규모 아트 검수 부담을 줄였다. 그리고 텍스처 상태를 한눈에 파악할 수 있는 **At a Glance** 디버그 셰이더를 활용해 밉맵이 화면에서 올바르게 사용되고 있는지를 시각적으로 판단할 수 있도록 하였다. 

<img src="./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250609020814090.png" alt="image-20250609020814090" style="zoom:50%;" />

*이미지 출처 : GDC 2017 - Texture Streaming in Titanfall 2*

</br>

</br>

------

### 텍스처 사용 정보를 시각적으로 보여주는 엔진 툴

대부분의 엔진에서는 색상 히트맵이나 텍스트 오버레이를 활용해, 아티스트가 실시간으로 텍스처 문제를 한눈에 파악할 수 있도록 지원하고 있다.

개인적으로 Unity에서 이 기능을 찾아보려고 했는데, 마땅한 툴이나 뷰 모드를 찾지 못해서 포기했다. ㅋ



#### 언리얼 엔진 - Straming Pool 

![image-20250609023507139](./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250609023507139.png)

*이미지 출처 : <a href="https://www.youtube.com/watch?v=uk3W8Zhahdg">https://www.youtube.com/watch?v=uk3W8Zhahdg</a>*

언리얼 엔진에서는 Streaming Pool 기능을 통해, 텍스처가 실제로 어떻게 스트리밍되고 있는지 색상맵 형태로 바로 확인할 수 있다. 이런 시각적 피드백이 아티스트 입장에서는 정말 큰 도움이 된다.

</br>

</br>

</br>

</br>