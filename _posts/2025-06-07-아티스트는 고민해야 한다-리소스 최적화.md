---
title: '아티스트는 고민해야 한다-메모리 편'
parmalink : /study/2025-06-01-1
date: 2025-06-01
tags:
  - Optimization
  - Com2us TA Campus
---

> 너무 많은 디바이스에 너무 많은 리소스들을 맞춰야 하는 앞으로의 아티스트들의 과제 

* [디바이스](#----)

  + [용어 정리](#-----)
  + [시대의 변화…](#-------)
  + [시대에 따른 디바이스의 변화](#---------------)
  * [최적화 기법](#------)
    + [유니티의 메모리 최적화](#------------)
    + [언리얼의 메모리 최적화](#------------)
    + [해상도 동적 스케일](#----------)
  * [사례](#--)
    + [길티기어의 내선 처리](#-----------)
    + [Decal을 이용한 Bevel](#decal------bevel)
    + [연도별 최적화 사례](#----------)
    + [텍스처 압축](#------)
  * [결론](#--)



아티스트에게 '최적화'라는 단어처럼 무겁고 어렵게 느껴지는 단어는 없을 것이다.

아티스트로서 작업에 몰입하다 보면 늘 심미성과 성능 퍼포먼스 사이에서 고민하게 된다. 실제로 유저에게 첫 반응을 이끌어 내는 것은 눈에 보이는 리소스이고 그에 따른 경험이다. 하지만 점점 게임들이 다양한 디바이스를 모두 지원하고 또, 한 프로젝트에 포함하는 컨텐츠의 양도 급격히 많아지는 시대가 오면서 이제는 **'게임을 아름답게 만드는 것'** 만큼, **'효율적인 에셋 관리로 무겁지 않은 그래픽을 만드는 것'**도 중요한 화두로 자리잡았다.

2000년대 초반만 해도, 우리가 다루는 텍스처와 모델의 버텍스는 기기 한계가 명확했기 때문에 사용할 수 있는 폼이 정해져 있었고, 콘솔이나 PC 모바일까지 각각 하드웨어 예산이 너무나도 달라 하나의 디바이스를 타겟팅해 그 안에서 예쁘게 만드는 것이 숙제였다. 하지만 2020년대에 들어서면서 하드웨어 스펙은 기하 급수적으로 성장하게 되었고, AAA 게임은 수십 GB 데이터를 불러와 유저에게 보여준다. 이제는 '메모리가 부족해서 못 넣는다'가 아니라, '메모리가 남아 돌아도, 돌리는 방식에 따라 언제든 병목이 터질 수 있다'라는 것을 늘 염두해 둬야 하는 것이다.



# 디바이스

## 시대의 변화

내가 처음으로 게임을 만들어보고 싶다는 생각을 한것이 2017년이다. 그 당시에 공부로 사용하던 툴은 비주얼 스튜디오 2014와 유니티 2017 버전이다. 2017년의 유니티는 빌트인 렌더 파이프라인이었고 셰이더 그래프 또한 없었기 때문에 참 어려운 툴이었다. 

게임 개발을 처음 시작한 이후로부터 8년, 사실 그렇게 긴 기간도 아닌데 업계는 너무나도 많은것이 바뀌고 있다. 

### **1. 하드웨어 세대 비교 (2000 vs 2020)**

| 디바이스            |           | 2000년대 사양        | 2020년대 사양                  |
| ------------------- | --------- | -------------------- | ------------------------------ |
| **플레이 스테이션** | CPU       | 294MHz               | 3.5GHz (약 12배 증가)          |
|                     | RAM       | 32MB                 | 16GB (약 500배 증가)           |
| **PC**              | CPU       | Pentium 4(단일 코어) | 고성능 프로세서(8-16코어)      |
|                     | RAM       | 256~512BM            | 32~64GB(약 100배 ~ 200배 증가) |
|                     | GPU       | GeForce 3/4          | RTX 40시리즈 (VRAM 24GB)       |
| **모바일**          | CPU       | 104MHz ARM           | 3.78GHz 6코어 (약 200배 향상)  |
|                     | RAM       | 6MB                  | 8GB (약 100배 증가)            |
|                     | 화면 크기 | 176x208 LCD          | 2556x1179 OLED                 |



위 표를 비교해봤을때 20년 사이에

1️⃣ 플레이 스테이션은 CPU 성능이 약 12배, 메모리는 500배 증가하면서 DVD 드라이브에서 SSD로 전환하며 하드웨어 레이트레이싱을 지원하기 시작했으며, 2️⃣ PC는CPU와 RAM도 큰 변화가 있었지만, 특히 그래픽 카드에서 가장 뛰어난 성능 향상을 보여주었다. 3️⃣ 모바일의 변화또한 굉장히 극적인데, 화면의 크기 변화도 주목할 만 하지만, 모바일도 하드웨어 레이 트레이싱을 지원하면서 스마트폰에서도 콘솔급 성능을 보여줄 수 있게 되었다. 

RAM의 성장만 그래프로 표현했을때,

<img src="./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image%20(1).png" alt="image (1)" style="zoom:50%;" />

그래프만 봐도 알 수 있듯, RAM 용량은 20년 만에 PC, 콘솔, 모바일 할 것 없이 상상할 수 없을 정도로 커졌다.
하지만 이 변화는 단순히 “용량이 늘었다”는 차원을 넘어선다.
플랫폼마다 메모리를 쓰는 방식, 그리고 최적화를 고민해야 하는 포인트 자체가 완전히 바뀌었다는 뜻이다.

이제부터는
**‘메모리가 많으니 아무 걱정 없이 써도 된다’는 착각이 오히려 문제가 될 수 있다는** 점을 아티스트는 이해하고 작업을 해야하는 것이다.



| 여기서 질문, RAM vs VRAM                                     |
| ------------------------------------------------------------ |
| **RAM (Random Access Memory)**<br />RAM은 시스템 메모리로, CPU가 직접 접근하여 운영체제와 애플리케이션이 사용하는 주메모리입니다. 프로그램 실행, 데이터 처리, 멀티태스킹 등 컴퓨터의 전반적인 작업을 담당합니다. CPU와 메인보드에 직접 연결되어 있으며, 시스템 전체의 성능에 직접적인 영향을 미칩니다.<br /><br />**VRAM (Video Random Access Memory)**<br />VRAM은 그래픽 전용 메모리로, GPU(그래픽 처리 장치) 내부에 위치하여 그래픽 관련 데이터만을 처리합니다. 텍스처, 프레임 버퍼, 셰이더 데이터 등 3D 렌더링과 화면 출력에 필요한 정보를 저장합니다. GPU에 물리적으로 가까이 위치하여 그래픽 처리에 최적화된 높은 대역폭을 제공합니다.<br /><br />처리 속도 측면에서 CPU보다 GPU가 더 나은 것처럼 VRAM이 RAM보다 그래픽 작업에 특화되어 더 빠른 처리속도를 갖고 있다. 하지만 접근성 측면에선 RAM은 CPU와 GPU 모두 가능하지만, VRAM은 주로 GPU만 접근이 가능하다. (용량은 일반적으로 RAM이 VRAM보다 훨씬 크다.)<br />게임에서는 두 메모리 모두 중요하다. RAM이 부족할 시 시스템 전체가 느려지고 VRAM이 부족할 시 텍스처 품질 저하나 프레임 드롭이 발생한다. 특히 최신 게임은 그래픽 퀄리티(주로 해상도)가 대폭 상승하면서 그 중요도가 높아졌기 때문에 충분한 VRAM 용량을 중요시 여기게 되었다. |



### **2. 디바이스의 변화에 따른 최적화 변화**

특히 2020년대에 들어서면서, ‘메모리 관리’는 그 어느 때보다 중요한 이슈로 떠올랐다.
단순히 예산을 맞추는 수준이 아니라, 장시간 플레이와 라이브서비스 환경에서 메모리 누수나 조각화가 실제 크래시로 이어지는 사례가 급증했다. 그래서 최근 엔진들은 이 부분을 아예 ‘툴’과 ‘프로파일러’ 수준에서 직접 다루기 시작했다.

#### 메모리 누수 관리 핵심 기법 

| **엔진**    | **대표 기능**                                                | **활용 포인트**                                              |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Unreal 5    | Low-Level Memory Tracker, MemReport, 샘스마트 포인터(SharedPtr) | 각 플랫폼이나 태그별로 메모리 상황을 따로 저장하고, 핫로딩(리소스 교체) 이후 얼마나 메모리가 더 쓰였는지 쉽게 비교할 수 있음 |
| Unity 2022+ | Memory Profiler 패키지 + Leaks 워크플로                      | 스냅샷을 비교해서 어떤 오브젝트가 메모리를 많이 쓰는지 찾아내고, 자동으로 C# 영역과 네이티브 영역(엔진 내부)의 사용량을 나눠서 보여줌 |
| 콘솔 SDK    | PS5 DevKit “GPA Memory Binning”, XSX PIX 메모리 시각화       | 전체 메모리를 여러 구역으로 나눠 관리하고, 실시간 구조(RT Acceleration Structure)가 조각나거나 비효율적으로 배치되는지 쉽게 확인할 수 있음 |



### 권장 RAM 가이드라인

**런처블 크래시***(launch crash, 게임이나 앱에서 실행(launch) 하자마자 곧바로 발생하는 크래시(비정상 적인 종료, 충돌)를 뜻함. 로고, 타이틀, 로딩창에서 발생하는 크래시들. 주요 원인은 과도한 메모리 사용으로 인한 리소스 불러오기 실패의 경우가 많다.)* 방지를 위해 기기 전체 RAM의 1/4~1/3 이내로 잡는 것이 안정적이다. 특히 모바일의 경우 백그라운드에서 실행되고 있는 앱이 많을 수록 메모리 사용량이 증가하기 때문에 게임 프로젝트의 메모리 스트리밍/해제 설계가 중요하다. 

2025년 기준 게임 개발 평균 가이드라인을 GPT에게 물어봤을때 권장 선은 다음과 같은 답변을 얻을 수 있었다. 

| 플랫폼          | RAM/VRAM (2025 기준) | 권장 텍스처 예산(런타임) |
| --------------- | -------------------- | ------------------------ |
| PC (구형)       | 2GB VRAM             | 1~1.2GB                  |
| PC (보급형)     | 4GB VRAM             | 2~2.5GB                  |
| PC (최신)       | 8GB+ VRAM            | 3~4GB+                   |
| 모바일 (저사양) | 2GB RAM              | 200~350MB                |
| 모바일 (중상급) | 4~6GB RAM            | 400~700MB                |
| 모바일 (최신)   | 8GB+ RAM             | 800MB~1.2GB              |



실제로, 

[윈도우11에서의 RAM사용량에 대한 분석글]: https://www.digitaltrends.com/computing/how-much-ram-does-windows-11-use/

 을 보았을때

- **8GB RAM 시스템**: Windows 프로세스가 2GB-4GB 이상 사용
- **32GB RAM 시스템**: 8GB-10GB까지 사용

한다고 표기하고 있다. 이는 8GB RAM 시스템에서 게임이 실제로 사용할 수 있는 메모리가 4-6GB에 불과하다는 것을 의미한다. 따라서 8GB를 최소 사양으로 설정하는 게임들조차 실제로는 매우 제한적인 메모리 예산 내에서 작동해야 한다는 사실을 보여주고 있다. 









----

# 최적화 기법

## 메모리 최적화 툴

### Unity : Memory Profiler

**Unity Memory Profiler**는 게임·앱 실행 중 메모리 스냅샷을 캡처 (정지화면처럼 보관)하고, 네이티브·관리 힙·GPU·그래픽 리소스를 탭별로 분석해 누수 · 조각화 · VRAM 초과 같은 문제를 찾아내는 공식 패키지다.



#### 실습

그래서, 현재 갖고 있는 가장 큰 프로젝트에서 유니티 메모리 프로파일러를 돌려보았다. 

*(해당 프로젝트는 대학생 팀 프로젝트로, 최적화 적 관점 없이 개발되었음을 밝힙니다😓)*

![image-20250608202044980](./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608202044980.png)

현재 게임은 steam에 올라가 있다. 게임은 8GB의 GTX 960 이상의 PC를 지원하고 있다. (이 당시 테스트 해볼 여력도 없어 작업실에서 가장 낮은 성능을 가진 컴퓨터로 테스트 해 최소 사양을 기록했었다.)

![image-20250608201956720](./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608201956720.png)

게임 플레이를 했을때 가장 처음 나오는 장면을 캡처한 결과다.

전체 메모리 사용량은 7GB로 꽤 높은 메모리 사용량을 보유하고 있었습니다. 총 7GB 사용량은 스팀에 명시된 권장사양을 만족하기엔 가능합니다. 하지만, Managed Heap(1.23GB)와 Objects(0.94GB)는 모두 C#에서 생성한 오브젝트와 데이터로 메모리가 과도하게 사용되고 있다는 것을 알 수 있었다.



<img src="./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608205705796.png" alt="image-20250608205705796" style="zoom: 67%;" />

리소스 쪽을 더 자세히 보자면, Texture2D + RenderTexture가 총 2.22GB로 전체 메모리의 약 32%를 차지하고 있었다. (1460개의 Texture2D와 174개의 RenderTexture)  가장 크게 차지하고 있는 건 라이트 맵이었는데, 한장에 42MB하는 이미지들이 10장 넘게 사용되고 있었다.

![image-20250608205931034](./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608205931034.png)![image-20250608205939893](./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608205939893.png)

어? 이상하다 라이트맵은 4장만 구웠었는데 하고 확인해보니 directional light, light, Shaddowmask 총 3가지 타입으로 4종류의 라이트맵을 만든것으로, 결과적으로 한장에 5MB하는 라이트맵을 총 12장씩이나 사용하고 있었다.

| 실제 라이트 맵은 5MB 하는데, 왜 메모리 프로파일러에선 42MB로 나오는가? |
| ------------------------------------------------------------ |
| <img src="./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608210909826.png" alt="image-20250608210909826" style="zoom: 67%;" /><br />디스크에 저장된 텍스처 파일은 5.3MB(DXT5/BC3 압축 기준) 정도로 작아 보인다.<br/> 하지만 이건 어디까지나 압축된 용량일 뿐, 실제로 게임이 실행될 때는 압축이 풀리면서 훨씬 더 큰 메모리를 차지하게 된다.<br /><br />예를 들어 2048×2048 RGBA 텍스처 한 장이 있다고 치자.<br/>압축이 모두 풀리면 2048 × 2048 × 4바이트(RGBA) = 약 16.78MB<br/>이게 바로 '한 장'의 실제 픽셀 데이터가 차지하는 메모리다. 외에도, 실제 게임에선 원본 텍스처만 사용하는게 아니라 여러 해상도의 밉맵을 자동으로 생성해 함께 사용한다. 예를 들어 원본 2048의 16.78MB 이미지가 있다고 가정했을때, <br />밉맵1(1024): 4.19MB<br />밉맵2(512): 1.05MB<br />밉맵3(256): 0.26MB<br />...이런 식으로 쭉 내려가면, 밉맵까지 모두 더하면 약 22.4MB가 된다.<br /><br />외에도, 라이트맵처럼 HDR 데이터를 사용하는 경우엔 일반 텍스처보다 훨씬 더 큰 포맷(16비트, 32비트)이 적용되면서 예상보다 훨씬 더 많은 메모리를 차지할 수 있다.<br /><br />그래서 에디터에선 5MB밖에 안돼 보이던 텍스처가 실제로 메모리에선 20~40MB, 그 이상까지 점유할 수도 있다. 때문에 텍스처 하나를 가볍게 보면 안되는 이유이기도 하다. |

---

### 해상도 동적 스케일

**‘해상도 동적 스케일’(Dynamic Resolution Scaling, DRS)이란?**

GPU 부하가 일정 한계(예: 16.6 ms/60 fps)를 넘으면 실시간으로 렌더 타깃 해상도를 낮췄다가, 여유가 생기면 다시 올려 프레임률을 안정시키는 적응형 렌더링 기법이다. 모바일처럼 전력·발열 제한이 큰 플랫폼에서 필수로 자리잡았다.

– 해상도는 0.5 × ~ 1.0 × 네이티브(50 % ~ 100 %) 범위를 보통 사용하고, 업스케일(Linear/FSR/Temporal)을 거쳐 화면에 출력한다.

scaleFactor 가 0.8이면 1080p 단말에서 864p로 내부 렌더링을 하고, 이후 업스케일·AA(안티 엘리어싱) 후 화면엔 1080p로 표시하는 것이다.

```mathematica
1)  프레임-타이밍 측정
2)  scaleFactor 조정 (예: 0.05 단위)
3)  렌더 목표 해상도 = 원본 × scaleFactor
4)  3D 렌더링  →  업스케일( TAAU / FSR / 빌리니어 )  →  HUD 합성
```



#### 👀 Dynamic Resolution Scaling 사용 사례를 찾아보다가...

##### 원신의 Dynamic Character Resolution 기능?

2024년 원신(Genshin Impact) 4.4 업데이트 내역에서 캐릭터 동적 해상도 기능이 플레이 스테이션에 도입되었다는 글을 찾을 수 있었다.

![image-20250608214715778](./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608214715778.png)

*이미지 출처 :https://genshin.hoyoverse.com/en/news/detail/122141<br>Dynamic Character Resolution에 대한 글 : https://game8.co/games/Genshin-Impact/archives/442438*

하지만 원신에서 제공하는 Dynamic Character Resolution 기능은 캐릭터 전용 업스케일 기능으로 품질 개선의 목적이 있는 기능으로 일반 DRS처럼 성능 확보 목적이 있다고 보기는 힘들다. 실제로 해당 기능을 끌 때 성능 개선에 더 도움이 된다는 이야기가 많았으며, 특히 저사양 기기에서 해당 기능을 활성화 했을 때 프레임 드랍이나 프레임 속도가 느려진다는 유저들의 이야기가 많았다.

<img src="./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/dynamic-character-resolution-on-and-off-v0-a6lr24n8dpfc1.jpeg" alt="r/Genshin_Impact - 동적 캐릭터 해상도 켜기 및 끄기" style="zoom:67%;" />

*이미지 출처 : https://www.reddit.com/r/Genshin_Impact/comments/1af945b/dynamic_character_resolution_on_and_off/ <br> 해당 기능을 켰을 때 캐릭터 폴리곤 모양이 부드럽게 처리되는 모습 확인 가능.*

이는 원신의 Dynamic Character Resolution 기능이 폴리곤의 계단 현상을 완화시키기 위해 AA(Anti-Aliasing)을 사용하면서 발생한 문제로 확인된다. 



----

## 최적화 사례

### 텍스처 압축

#### 텍스처 메모리 다이어트

위의 개인 프로젝트의 메모리 프로파일러를 살펴 보더라도, 게임 메모리를 대부분 차지하는 리소스는 2D 텍스처라는 사실을 알 수 있다. 그렇기 때문에 2D 텍스처가 많이 등장하는 스프라이트 애니메이션을 중심으로 한 게임들은 텍스처 메모리를 과도하게 사용할 수 밖에 없고, 이는 특히 모바일 기기에서 심각한 성능 이슈를 일으킬 수 있다. 

이 문제를 해결하기 위해 주로 아틀라스로 텍스처들을 묶어 효율적으로 메모리를 사용하려는 노력을 하지만 아틀라스도 빈 공간에서 발생하는 메모리 낭비에 대한 문제가 있기 때문에 완벽한 해결책이라고 하기 힘들다.

GDC 2018에서 텍스처 메모리에 대한 최적화에 대해 설명한 사례가 있어 이를 알아보고자 한다.

나이트 인 더 우즈를 개발한 개발사 Secret Lab는 게임을 PC에서 IOS로 포팅하는 과정에서 해결한 메모리 최적화 문제에 대해 이야기하고 있다. PC 버전을 개발할 땐 4GB 메모리에 맞춰 만들었지만, IOS 기기중 가장 사양이 낮은 기기는 1GB의 메모리를 사용하고 있었고 실제로 앱이 사용 가능한 메모리 공간은 600MB에 불과했다. 때문에 게임 메모리를 차지하는 대부분의 리소스인 스프라이트 이미지를 어떻게든 압축할 필요가 생겼다. 

<img src="./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608225426959.png" alt="image-20250608225426959" style="zoom:50%;" /><img src="./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250608225451170.png" alt="image-20250608225451170" style="zoom:50%;" />

*이미지 출처 : GDC 2018 - By Grabthar's Hammer, What A Savings.*

이 문제를 해결하기 위해 Sprite Dicing이라는 기능을 개발했다고 한다. 이 기능은 스프라이트를 작은 조각들로 분할한 후, 동일한 부분을 식별하여 중복을 제거하는 것이다. 예를 들어, 캐릭터의 여러 감정 표현에서 신체 부분은 동일하고 얼굴 표정만 다른 경우, 공통된 신체 부분은 한 번만 저장하고 변화하는 얼굴 부분만 별도로 관리하는 것이다. 이를 통해 나이트 인더 우즈의 대부분의 텍스처는 아틀라스의 활용도를 극대화하면서도 메모리 낭비를 최소화 할 수 있었다.

이 기능을 통해 주인공 캐릭터 Mae의 Run 스프라이트 애니메이션은 23개의 720*720 스프라이트로 압축할 수 있었고, 이는 2.68MB의 원본 리소스를 1.5MB까지 줄일 수 있었다. (원본은 55%)

<img src="./../images/2025-06-07-%EC%95%84%ED%8B%B0%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%20%EC%B5%9C%EC%A0%81%ED%99%94/image-20250609000943273.png" alt="image-20250609000943273" style="zoom:50%;" />

Sprite Dicing은 움직이지 않는 부분이 많은 물체에 대해서 훨씬 더 나은 성능을 보여줬는데, 침대 애니메이션(담요가 펄럭거리는)에서는 원본 9.76MB에서 1.5MB로 원본의 15%정도로 텍스처를 압축할 수 있었다.



하지만 해당 기능은 하나의 큰 스프라이트를 여러개의 작은 조각으로 분리하기 위해 조각마다 다른 UV 좌표가 필요했고, 때문에 2D 게임인데도 불구하고 메시 렌더러(유니티)를 사용할 수 밖에 없었다. 때문에 Sprite Dicing 작업을 진행하면서 더 많은 폴리곤 수가 들었지만 개발팀은 해당 방법이 메모리를 절약하는데 가장 좋은 방법이라고 판단하였다.





## 아티스트를 돕는 최적화 UX 툴

사실 아티스트가 이런 세세한 부분까지 생각하며 작업하는건 불가능 하다고 생각해. 아티스트는 기술적 관점보다는 심미적 관점에서 작업을 하다 보니 잘 몰라서 최적화 관점을 놓치는것도 있겠지만, 아티스트의 특성이라고 해야하나 이런 부분때문에 하나하나 메모리 발열 GPU 병목 이런것까지 고려하면서 작업하는건 어렵다고 생각해.

그렇다고 기술(프로그래밍팀이나 TA팀)팀에서 아트팀이 올리는 리소스를 다 검수하는것도 힘들텐데… 어떤 협업 워크플로우가 가장 현실적이고 융통성 있을까?

아티스트는 심미성에 집중하면서도 메모리, 발열, GPU 병목같은 제약을 가시화해 문제를 시각화 하는 것으로 해결하는 것이 바람직함. “사람 대신 파이프라인이 검수” 한다는 것. TA가 룰과 지표를 설계하고 도구, 대시보드로 실시간으로 사람이 없어도 피드백이 가능한 환경을 제공.

타이탄폴 2 게임은 멀티플레이, 세미 오픈월드 게임이다. PS4, XBO, PC에서 60 fps 4K 텍스처 유지를 목표로 하며 VRAM 3GB, HDD 40BM/s 환경에서 이를 만들어야 했다. 여기서 추가로 더 건 제약은 아티스트 텍스처 최적화 수작업 금지.이다. 아티스트가 텍스처 최적화에 신경 안 써도 되는 자동 시스템을 만드는 것이 팀의 목표다.

- 자동 텍스처 스트리밍 (히스토그램 기반)
  - 게임 맵을 16비트 크기 타일로 나누고, 각 타일에 프로브 카메라를 설치한다. GPU가 이 카메라들을 보는 장면을 큐브맵으로 렌더링하고 이 렌더링된 밉맵의 사용률을 **히스토그램(픽셀 분포)**로 기록한다.
  - 그리고 .stbsp 파일로 4*4 타일 묶음의 데이터 페이지로 패킹하고, 밉맵 정보중 중요한 512개만 저장해 압축한다.
  - 그래서 플레이 할땐 플레이어가 있는 영역과 보이는 곳만 계산하고, 중요한 텍스처는 더 선명하게, 덜 중요한건 해상도 낮게 출력한다.
- Cruncher (자동 검수 툴)
- 아티스트를 위한 UX 기능
  - 낭비된/부족한 MIP을 색으로 표시
  - UV 밀도, 타일 여부 상관없이 화면에 얼마나 보이냐만 판단

Respawn은 툴이 대신 최적화해야한다는 철학으로

- 아티스트는 작업만 하고,
- 자동 스트리밍 시스템 + 시각적 피드백

을 통해 4K 텍스처와 콘솔 대응을 동시에 달성한 사례를 이야기 하고 있다.

------

1. 타일·히스토그램 사전 계산을 빌드 서버가 처리 → 아트팀은 ‘제출 버튼’만 눌러도 텍스처 예산이 자동 관리.
2. 시각적 디버그 셰이더 + 최소한의 힌트 태그가 현업 디자이너·아티스트가 이해할 수 있는 유일한 인터랙션.
3. 기술 측면(스트리머 코드·CI·메모리 정책)은 TA·엔지니어가 소수 인원으로 집중 유지, 대규모 아트 검수 부담을 제거.

------

**‘밉맵이 제대로 쓰이는지’ 한눈에 보여 준 대표 UX 사례 4선**

(모두 색상 히트맵·텍스트 오버레이로 아티스트가 즉시 문제를 찾게 해 준 접근이다)

| **스튜디오·엔진**                                            | **디버그 모드 / 툴 이름**                                    | **화면에 표시되는 컬러 의미**                                | **참고 자료**                                                |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Epic Games – Unreal Engine                                   | Texture Streaming Accuracy ViewMode콘솔: viewmode streamingaccuracy | Green = 목표 Mip 정확, Yellow = 낭비 Mip(과대), Red = 부족 Mip(저해상도), Blue = 스트리밍 Off | [UE Docs “Building Texture Streaming Data” + “Streaming Config”](https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Textures/Streaming/Building?utm_source=chatgpt.com) |
| https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Textures/Streaming/Config?utm_source=chatgpt.com |                                                              |                                                              |                                                              |
| Unity                                                        | Scene View Texture Streaming Debug Draw Mode                 | Green = 정상 로드, Red = 풀 초과로 낮은 Mip, Blue = 스트리밍 미사용 | [Unity Manual “Analyze mipmap streaming”](https://docs.unity3d.com/6000.1/Documentation/Manual/TextureStreaming-analyze.html?utm_source=chatgpt.com) |
| https://docs.unity3d.com/6000.1/Documentation/Manual/TextureStreaming-analyze.html?utm_source=chatgpt.com |                                                              |                                                              |                                                              |
| Respawn – Titanfall 2                                        | 사내 툴 Streaming Heatmap Shader                             | Red = 불필요 풀 Mip, Cyan = 스트리머 예측 실패, Grey = 동적 힌트 필요 | [GDC 2017 PDF p.38 “Debug Colour View”](https://ubm-twvideo01.s3.amazonaws.com/o1/vault/gdc2017/Presentations/Barb_Chad_EfficientTextureStreaming.pdf?utm_source=chatgpt.com) |

위 사례처럼 색상 Heatmap + 숫자 HUD 만으로 검수 부담을 파이프라인이 대신 처리할 수 있다.

https://media.gdcvault.com/gdc2015/presentations/Olsen_Morten_TheUltimateTrim.pdf

그리드-스냅 UV 스크립트



최적화에는 정답은 없다. 

만드는 게임의 장르나 타겟 플랫폼을 떠나 프로젝트의 규모, 인원, 재정 상태에 따라서도 팀마다 추구하는 최적화 관점이나 리소스의 중요도(가치)가 다르기 때문이다. 하지만, 모두에게 공통적으로 적용되는 부분이 있다면 이런 내용을 얼마나 팀원들이 잘 숙지하고 있고, 위험 요소까지 생각하며 상황에 대해 선택하는지가 중요하다.

이 글에서는 시대별 디바이스 성능의 변화와, 실제 현업에서 검수 부담을 줄이기 위한 워크플로우, 그리고 텍스처 메모리 최적화 사례까지, 최근 그래픽 파이프라인에서 고민되는 핵심 이슈들을 함께 정리해보고자 한다.
 플랫폼이 아무리 다양해져도, **아트와 기술의 접점**은 늘 ‘보이면서도 효율적인 리소스’를 고민하는 데 있다는 사실.
 이 글이 같은 고민을 하는 아티스트와 개발자들에게 작은 참고가 되었으면 한다.