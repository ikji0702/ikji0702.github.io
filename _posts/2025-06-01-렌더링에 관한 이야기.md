---
title: '렌더링에 관한 이야기'
parmalink : /study/2025-06-01-1
date: 2025-06-01
tags:
  - Rendering
  - Com2us TA Campus
---


> 아티스트의 렌더 파이프라인 탐험기

- CPU에서 하는 컬링 : 오브젝트 단위로 컬링
- GPU에서 하는 컬링 : 삼각형 단위로 컬링

## 렌더링

![Untitled](./../images/2025-06-01-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%97%90%20%EA%B4%80%ED%95%9C%20%EC%9D%B4%EC%95%BC%EA%B8%B0/Untitled.webp)

> 이미지 참고 : https://docs.microsoft.com/ko-kr/windows/uwp/graphics-concepts/graphics-pipeline

Direct3D 그래픽 파이프 라인은 실시간 그래픽을 생성하는데 설계된 파이프 라인입니다. + 모서리가 둥근 사각형 블록은 HLSL 프로그래밍 언어를 사용해 프로그래밍 할 수 있습니다.



| 스테이지                 | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| **IA (Input Assembler)** | 정점, 선, 삼각형 등 원시 데이터를 읽고, 정점 리스트나 삼각형 스트립 등으로 정리함 |
| **VS (Vertex Shader)**   | 정점 위치 변환, 스키닝, 버텍스 라이트 계산 등 **버텍스 처리** 수행 |
| **HS (Hull Shader)**     | 테셀레이션 여부 판단, 얼마나 쪼갤지 결정                     |
| **TS (Tessellator)**     | 실제로 폴리곤을 더 잘게 나눔 (예: 사각형 → 삼각형)           |
| **DS (Domain Shader)**   | 분할된 점들의 정확한 위치를 계산                             |
| **GS (Geometry Shader)** | 기존 정점 정보를 기반으로 새로운 정점, 선, 면 생성 가능 (선택적) |
| **RS (Rasterizer)**      | 3D 정점을 **2D 픽셀로 변환**, 보간값 계산, 뷰 컬링 수행      |
| **PS (Pixel Shader)**    | 픽셀 색상 결정, 라이팅/쉐이딩/텍스처 적용 등 **비주얼 연산 처리** |
| **OM (Output Merger)**   | Z 버퍼, 스텐실, 블렌딩 처리 후 **최종 픽셀 색상 결정**       |



좀 더 자세히 설명해봅시다.

IA에서 3D 모델을 받아 정점 쉐이더의 입력 값으로 넘깁니다. 그럼 입력 값으로 위치 벡터, 노말 벡터, 색상 등을 정보로 받겠죠? 이 정보들을 카메라 기준의 위치로 변환합니다. 그렇게 카메라에서 바라보는 정점 데이터들을 다음 스택으로 넘기게 됩니다. 이 과정에서 우리는 직접 정점 셰이더를 통해 위치를 의도대로 변경하거나, 모양을 바꾸거나 움직이게 할 수 있습니다. 

![GIF 2022-04-06 오후 6-42-25](./../images/2025-06-01-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%97%90%20%EA%B4%80%ED%95%9C%20%EC%9D%B4%EC%95%BC%EA%B8%B0/GIF%202022-04-06%20%EC%98%A4%ED%9B%84%206-42-25.gif)

영상 설명 : https://www.youtube.com/watch?v=LAsnQoBUG4Q

이 3D 정점 데이터들을 저희는 2D 스크린 공간으로 변환할 예정입니다. 이 과정을 래스터라이저(Rasterizer)라고 합니다. 래스터라이즈 단계는 3D 그래픽을 표시하기 위해 벡터 정보를 픽셀 이미지로 변환하는 과정입니다. 입력으로 받은 정점 데이터들을 2D 스크린 공간으로 변환하고, 화면에 출력할 픽셀들을 모두 찾아 픽셀들을 출력해줍니다.  

> ![Untitled (3)](./../images/2025-06-01-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%97%90%20%EA%B4%80%ED%95%9C%20%EC%9D%B4%EC%95%BC%EA%B8%B0/Untitled%20(3).png)
>
> 레스터라이즈라는 단어를 들었을때 포토샵의 래스터라이즈 레이어 기능을 떠올리신 분들이 많으실텐데요, 실제로 포토샵에서도 비트맵(Bitmap)혹은 벡터(Vector)로 표현된 이미지나 문자를 픽셀이나 점으로 이루어진 배열로 변환할 때 쓰이는 기능입니다. 이미지 깨기, 문자 깨기로도 표현되는 이 기능은 모양 레이어를 지우개, 브러쉬, 연필 등 여러 기능의 사용을 활성화 하기 위해 사용됩니다. 



![Untitled (6)](./../images/2025-06-01-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%97%90%20%EA%B4%80%ED%95%9C%20%EC%9D%B4%EC%95%BC%EA%B8%B0/Untitled%20(6).png)

> Direct X의 표기

![](./../images/2025-06-01-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%97%90%20%EA%B4%80%ED%95%9C%20%EC%9D%B4%EC%95%BC%EA%B8%B0/Untitled%20(4).png)

> 유니티 셰이더 그래프에서의 표기

DirectX에서는 픽셀 쉐이더, OpenGL과 유니티 엔진에서는 프래그먼트 쉐이더(Fragment Shader)라고 부릅니다. 래스터라이즈 단계를 거친 픽셀들의 색상을 계산하고, 픽셀이 화면에 출력될 색상을 결정해줍니다. 투명도를 결정해주는 것도 픽셀 셰이더, 라이팅과 그림자를 적용하는 것도 픽셀 셰이더, 알베도, 노말, 메탈릭 등 메시에 옷을 입히는 것도 모두 픽셀 쉐이더에서 처리하는 일입니다. 

![Untitled (7)](./../images/2025-06-01-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%97%90%20%EA%B4%80%ED%95%9C%20%EC%9D%B4%EC%95%BC%EA%B8%B0/Untitled%20(7).png)

위의 이미지는 OpenGL의 그래픽 파이프라인 입니다. Pixel Shader가 아닌, Fragment Shader가 존재함을 알 수 있습니다.





## 디퍼드 vs 포워드 렌더링

렌더 파이프라인이 큰 단계라면, 포워드와 디퍼드 렌더링은 그 단계 안에서 조명과 머테리얼을 어떻게 처리할지 결정하는 단계입니다. 

디퍼드(Deferred) 렌더링과 포워드(Forward) 렌더링은 그래픽 렌더 파이프라인의 대표적인 두가지 방식입니다.
 3D 모델을 픽셀 이미지로 바꾸는 단계에서 조명(라이트)와 재질(머테리얼)을 어떻게 처리할지에 따라 렌더링 방식(포워드냐 디퍼드냐)이 달라집니다.

|                  항목 | **Forward Rendering**        | **Deferred Rendering**                  |
| --------------------: | ---------------------------- | --------------------------------------- |
|             처리 방식 | 즉시 조명과 셰이딩 계산      | 먼저 **G-Buffer**에 저장 후 나중에 처리 |
| 실시간 처리 라이트 수 | 적음                         | 많음 (수십 개도 가능)                   |
|                그림자 | 라이트 수에 비례해 비용 증가 | 한 번에 조명 적용 가능                  |
|                  성능 | 저렴한 GPU/모바일에 좋음     | 데스크탑/콘솔에서 고성능                |
|             투명 처리 | 쉬움                         | 어려움 (G-Buffer 사용 한계)             |
|           후처리 효과 | 제한적                       | 블룸, SSAO 등 고급 후처리 용이          |
|                  예시 | Unity 기본, URP              | Unreal, Unity HDRP                      |



조금 더 자세히 두 렌더링의 차이에 대해 이야기 해보겠습니다.

### Forward Rendering

![image-20250604002445878](./../images/2025-06-01-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%97%90%20%EA%B4%80%ED%95%9C%20%EC%9D%B4%EC%95%BC%EA%B8%B0/image-20250604002445878.png)

- **주요 특징**: 각 객체가 렌더링될 때 조명 계산
- **장점**: 메모리 효율적, 모바일 환경에 적합

포워드 렌더링에는 멀티패스 방식과 싱글패스 방식이 존재하는데

멀티패스는 위에 언급한 대로 씬에 있는 모든 라이팅과 계산을 하는 방식이다 이 때문에 라이팅이 많아질 경우 성능이 굉장히 떨어지게 된다. 라이팅이 10개가 있고, 오브젝트가 10개가 있다면 10 x 10 = 100번의 연산이 필요하다(라이팅만을 위한 계산량) 

포워드 렌더링은 많은 동적 라이트를 다루는데 한계가 있어, 유니티에선 멀티패스로 성능을 포기하는 Built-in과 싱글패스로 라이트를 제한하는 URP 로 종류를 나누어 사용하고 있다.



### Deferred Rendering

![image-20250604003433936](./../images/2025-06-01-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%97%90%20%EA%B4%80%ED%95%9C%20%EC%9D%B4%EC%95%BC%EA%B8%B0/image-20250604003433936.png)

오브젝트 하나하나가 렌더링 시 라이팅 계산을 하는 포워드 렌더링과는 다르게,

디퍼드 렌더링은 G-buffer(Geometry-buffer)라는 곳에 diffuse, depth, normal map 등 라이팅에 계산에 필요한 속성들을 저장한다. 그리고 오브젝트를 최종 렌더링 시 이 G-buffer의 정보를 가져와 그린다. 이 과정을 모든 오브젝트가 수행하고 나서 라이팅 연산을 수행한다.

이 때문에 오브젝트가 얼마나 존재하던 라이팅 연산은 딱 1번만 수행한다.

따라서 많은 수의 ***실시간 라이팅(동적 라이팅)을 비교적 좋은 성능으로 처리***할 수 있다. 많은 수의 ***실시간 라이트들의 드로우 콜에 대한 부담을 줄일 수 있다***. 하지만 뒤에 그려지는 오브젝트 정보가 비디오 메모리에서 소실되기 때문에 ***알파가 빠지는 오브젝트를 표현할 수 없다.***

요구하는 ***하드웨어 사양이 포워드 렌더링 방식보다 높고, 해상도가 올라갈 수록 요구하는 메모리가 기하급수로 늘어난다.***



## G-Buffer와 C-Buffer

### G-Buffer

지오메트리 버퍼, G 버퍼는 그래픽 렌더 파이프라인 중 한 단계로, 쉽계 표현해 **촬영 현장의 정보가 담긴 기록지**라고 표현할 수 있습니다. 예를 들어, 영화 한 장면을 찍는다고 했을때 이 정보를 모두 감독들은 따로 적어둡니다.

- 카메라 위치와 각도 -> 위치 정보
- 조명 방향 -> 노말 정보
- 배경 색감 -> 알베도
- 피사체 거리 -> Depth(깊이) 정보

이렇게 적어놓은 데이터들을 모아 둔 곳이 G 버퍼 입니다. 

G 버퍼는 렌더링을 두 번 안하고도, 한 번 저장해 두었던 정보들을 꺼내 또 렌더할때 이전 정보들을 가지고 다시 계산하거나 조절하기 쉽기 때문입니다. 보통 화면 포스트 프로세싱(화면 후처리 효과), Global Illumination 같은 화면 효과 연산에 사용됩니다. 보통 디퍼드 렌더링 (Deferred Rendering)에서 많이 사용 됩니다. 



#### G 버퍼가 모바일에서 무거운 이유?

G 버퍼는 보통 여러 개의 텍스처를 사용해 아래 정보를 나눠 저장합니다.

- Postion
- Normal
- Albedo
- Smoothness, Metallic 등

모바일 GPU는 동시에 여러 렌더를 타겟(MRT : Multiple Render Targets이라고도 칭함)하는 능력이 제한적입니다. 또, G 버퍼는 보통 HDR 포맷을 사용하기 때문에 저장 용량이 큰데, 모바일은 메모리 대역폭 또한 PC나 콘솔에 비해 낮기 때문에 메모리 병목 현상이 발생할 수 있습니다.



#### Single Pass Deferred 

이러한 문제들로 **Single Pass Deferred**라는 최적화 옵션이 존재합니다.

Single Pass Deferred는 기존 디퍼드 렌더링보다 메모리 사용량과 성능을 개선한 최적화 기법입니다. 이름 그대로 한번의 패스(Pass)로 모든 G 버퍼 정보를 그리는 기법입니다. 1개 텍스처에 압축해 정보를 저장하기 때문에 메모리를 적게 쓰기 때문에 성능 향상 효과가 있습니다.

단, 데이터를 압축해 저장하기 때문에 정밀도 손실이 발생할 수 있으며 하나의 텍스처에 여러 정보가 저장되다 보니 후처리, 셰이더 개발자 입장에선 불편한 구조라는 단점이 있습니다.







### C-Buffer

G 버퍼와 헷갈렸던 C 버퍼, C 버퍼는 무엇인가요?

커멘드 버퍼라고도 칭하는 C 버퍼는 명령 또는 커맨드를 저장하는 버퍼입니다. 쉽게 표현하면 렌더링 명령어들을 미리 적어두는 메모장이라고 할 수 있습니다. 렌더링 할 때마다 명령어를 일일이 싫애하는게 아니라, 미리 정리해놓고, 한번에 처리할 수 있도록 합니다. 이렇게 처리하면 더 빠르고 효율적으로 명령을 처리할 수 있습니다.

커맨드 버퍼를 사용하면, 이 명령 중간 중간에 작업자가 원하는 작업을 끼워 넣을 수 있습니다.

실제 사용을 예로 들면,

```csharp
// cb 이름의 커맨드 버퍼를 만들고,
CommandBuffer cb = new CommandBuffer();

// 화면 이미지를 myMaterial을 활용해 가공합니다.
// Blit 함수는 이미지나 텍스처를 다른 텍스처로 복사하거나 후처리 효과를 적용할 때 사용하는 함수입니다.
cb.Blit(source, destination, myMaterial);

// AddCommandBuffer를 통해 이 작업이 카메라가 후처리를 끝낸 직후에 실행하도록 예약.
camera.AddCommandBuffer(CameraEvent.AfterImageEffects, cb);
```





|             | 효과                               | 커맨드 버퍼의 역할                                           |
| ----------- | ---------------------------------- | ------------------------------------------------------------ |
| 블러 (굴절) | 배경을 흐릿하게, 굴절 효과         | 굴절에 사용될 텍스처를 전달                                  |
| 데칼        | 메쉬 표면에 자국, 문양 등 덧그리기 | 데칼용 프로젝터 메쉬를 커맨드 버퍼에서 렌더링하고 이를 덮어씌울 오브젝트 표면에 덧그림 |

https://docs.unity3d.com/kr/2019.3/Manual/GraphicsCommandBuffers.html 참고



G 버퍼와 C 버퍼(커맨드 버퍼)는 결론적으로 완전 다른 기능입니다. 요약하자면

| G 버퍼                                  | C 버퍼                                    |
| --------------------------------------- | ----------------------------------------- |
| **데이터 저장용** (색상, 노멀, 깊이 등) | **명령 저장용** (이거 그려! 저거 복사해!) |
| 렌더링의 **결과**를 담음                | 렌더링을 **어떻게 할지** 계획을 담음      |





